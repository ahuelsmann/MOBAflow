    /// <summary>
    /// Attempts to recover a non-responsive Z21 by sending a recovery byte sequence.
    /// This can help when the Z21 stops responding without requiring a hardware restart.
    /// 
    /// Recovery Sequence (based on Z21 protocol behavior):
    /// 1. Emergency Stop (0x06 0x00 0x40 0x00 0x80 0x80) - "Kicks" the Z21 awake
    /// 2. LAN_LOGOFF (0x04 0x00 0x30 0x00) - Clears any hanging client session
    /// 3. LAN_GET_SERIAL_NUMBER (0x04 0x00 0x10 0x00) - Simple command that always responds
    /// 4. LAN_SYSTEMSTATE_GETDATA (0x04 0x00 0x85 0x00) - Re-establish connection
    /// 5. LAN_SET_BROADCASTFLAGS (0x08 0x00 0x50 0x00 0xFF 0xFF 0xFF 0xFF) - Re-subscribe
    /// 6. LAN_X_GET_STATUS - Final status check
    /// </summary>
    public async Task RecoverConnectionAsync(CancellationToken cancellationToken = default)
    {
        _logger?.LogWarning("üîÑ Attempting Z21 recovery with byte sequence...");
        
        try
        {
            // Step 1: Emergency Stop - This often "wakes up" a stuck Z21
            await SendAsync(Z21Command.BuildEmergencyStop(), cancellationToken).ConfigureAwait(false);
            _logger?.LogDebug("Recovery: Emergency Stop sent (wake-up kick)");
            await Task.Delay(100, cancellationToken).ConfigureAwait(false);
            
            // Step 2: LOGOFF - Clear any hanging client session
            await SendAsync(Z21Command.BuildLogoff(), cancellationToken).ConfigureAwait(false);
            _logger?.LogDebug("Recovery: LOGOFF sent (clear session)");
            await Task.Delay(150, cancellationToken).ConfigureAwait(false);
            
            // Step 3: GET_SERIAL_NUMBER - Simple command that Z21 should always respond to
            await SendAsync(Z21Command.BuildGetSerialNumber(), cancellationToken).ConfigureAwait(false);
            _logger?.LogDebug("Recovery: GET_SERIAL_NUMBER sent (test response)");
            await Task.Delay(100, cancellationToken).ConfigureAwait(false);
            
            // Step 4: Handshake - Re-establish connection
            await SendHandshakeAsync(cancellationToken).ConfigureAwait(false);
            _logger?.LogDebug("Recovery: Handshake sent (re-establish)");
            await Task.Delay(100, cancellationToken).ConfigureAwait(false);
            
            // Step 5: Re-subscribe to broadcasts
            await SetBroadcastFlagsAsync(cancellationToken).ConfigureAwait(false);
            _logger?.LogDebug("Recovery: Broadcast flags set (re-subscribe)");
            await Task.Delay(100, cancellationToken).ConfigureAwait(false);
            
            // Step 6: Request status - Verify connection is alive
            await GetStatusAsync(cancellationToken).ConfigureAwait(false);
            _logger?.LogDebug("Recovery: Status requested (verify)");
            
            // Reset keepalive failure counter on successful recovery
            _keepAliveFailures = 0;
            
            _logger?.LogInformation("‚úÖ Z21 recovery sequence completed");
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "‚ùå Z21 recovery failed");
            throw;
        }
    }
