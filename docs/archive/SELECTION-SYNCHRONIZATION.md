# Selection Synchronization Architecture

**Datum**: 2025-11-30  
**Status**: ‚úÖ **Implemented**

---

## üéØ **Problem behoben:**

**Vorher:** Jede View hatte **eigene** Selection-Properties ‚Üí Keine Synchronisation!

| View | Selection Property | ViewModel |
|------|-------------------|-----------|
| ExplorerPage (TreeView) | `CurrentSelectedNode` (private) | MainWindowViewModel |
| EditorPage | `JourneyEditor.SelectedJourney` | EditorPageViewModel |
| ConfigurationPage | `SelectedJourney` | ProjectConfigurationPageViewModel |

**‚ùå Ausw√§hlen in TreeView** ‚Üí Editor & Configuration wussten nichts davon!

---

## ‚úÖ **L√∂sung: Unified Selection in MainWindowViewModel**

**MainWindowViewModel** ist jetzt **Single Source of Truth** f√ºr alle Selections!

### **Neue Properties in MainWindowViewModel:**

```csharp
[ObservableProperty]
private TreeNodeViewModel? currentSelectedNode;  // Root selection (TreeView)

[ObservableProperty]
private JourneyViewModel? selectedJourney;       // ‚Üê Shared!

[ObservableProperty]
private StationViewModel? selectedStation;       // ‚Üê Shared!

[ObservableProperty]
private WorkflowViewModel? selectedWorkflow;     // ‚Üê Shared!

[ObservableProperty]
private TrainViewModel? selectedTrain;           // ‚Üê Shared!
```

### **Automatische Synchronisation:**

```csharp
public void OnNodeSelected(TreeNodeViewModel? node)
{
    CurrentSelectedNode = node;
    
    // ‚úÖ Reset all
    SelectedJourney = null;
    SelectedStation = null;
    SelectedWorkflow = null;
    SelectedTrain = null;
    
    // ‚úÖ Set based on selected node type
    switch (node.DataContext)
    {
        case JourneyViewModel jvm:
            SelectedJourney = jvm;  // ‚Üê Alle Views sehen das!
            break;
        case StationViewModel svm:
            SelectedStation = svm;
            break;
        // ...
    }
}
```

---

## üîÑ **Datenfluss:**

```
User klickt Journey im TreeView
  ‚Üì
ExplorerPage.xaml.cs: SolutionTreeView_ItemInvoked()
  ‚Üì
MainWindowViewModel.OnNodeSelected(TreeNodeViewModel)
  ‚Üì
MainWindowViewModel.SelectedJourney = journeyVM
  ‚Üì
PropertyChanged Event gefeuert
  ‚Üì
EditorPageViewModel.SelectedJourney (pass-through)
  ‚Üì
EditorPage ListView.SelectedItem aktualisiert ‚úÖ
  ‚Üì
ConfigurationPageViewModel.SelectedJourney (pass-through)
  ‚Üì
ConfigurationPage ListView.SelectedItem aktualisiert ‚úÖ
```

**Alle 3 Views zeigen die gleiche Journey als ausgew√§hlt!** üéØ

---

## üìä **Implementation Details:**

### **1. MainWindowViewModel (Source of Truth)**

```csharp
// Direct properties - auto-generated by ObservableProperty
public JourneyViewModel? SelectedJourney { get; set; }
public StationViewModel? SelectedStation { get; set; }
public WorkflowViewModel? SelectedWorkflow { get; set; }
public TrainViewModel? SelectedTrain { get; set; }
```

### **2. EditorPageViewModel (Pass-Through)**

```csharp
private readonly WinUI.MainWindowViewModel? _mainWindowViewModel;

// Pass-through properties - delegate to MainWindowViewModel
public JourneyViewModel? SelectedJourney
{
    get => _mainWindowViewModel?.SelectedJourney;
    set { if (_mainWindowViewModel != null) _mainWindowViewModel.SelectedJourney = value; }
}

// Subscribe to changes
_mainWindowViewModel.PropertyChanged += (s, e) =>
{
    if (e.PropertyName == nameof(_mainWindowViewModel.SelectedJourney))
        OnPropertyChanged(nameof(SelectedJourney));
};
```

**Constructor:**
```csharp
public EditorPageViewModel(
    Solution solution, 
    ValidationService? validationService, 
    WinUI.MainWindowViewModel? mainWindowViewModel)  // ‚Üê NEW!
{
    _mainWindowViewModel = mainWindowViewModel;
    // ...
}
```

**DI Registration:**
```csharp
services.AddSingleton<EditorPageViewModel>(sp =>
{
    var solution = sp.GetRequiredService<Solution>();
    var validationService = sp.GetRequiredService<ValidationService>();
    var mainWindowViewModel = sp.GetRequiredService<WinUI.MainWindowViewModel>();
    return new EditorPageViewModel(solution, validationService, mainWindowViewModel);
});
```

### **3. ProjectConfigurationPageViewModel (Pass-Through)**

```csharp
private readonly WinUI.MainWindowViewModel? _mainWindowViewModel;

// Pass-through properties
public JourneyViewModel? SelectedJourney
{
    get => _mainWindowViewModel?.SelectedJourney;
    set
    {
        if (_mainWindowViewModel != null && _mainWindowViewModel.SelectedJourney != value)
        {
            _mainWindowViewModel.SelectedJourney = value;
            OnSelectedJourneyChanged(value);  // ‚Üê Side effects (update Commands)
        }
    }
}

// Constructor
public ProjectConfigurationPageViewModel(
    Project project, 
    IPreferencesService? preferencesService, 
    WinUI.MainWindowViewModel? mainWindowViewModel)  // ‚Üê NEW!
{
    _mainWindowViewModel = mainWindowViewModel;
    
    // Subscribe to changes
    _mainWindowViewModel.PropertyChanged += (s, e) =>
    {
        if (e.PropertyName == nameof(_mainWindowViewModel.SelectedJourney))
            OnPropertyChanged(nameof(SelectedJourney));
    };
}
```

**Navigation:**
```csharp
case "configuration":
    var configViewModel = new ProjectConfigurationPageViewModel(
        project, 
        preferencesService, 
        ViewModel);  // ‚Üê Pass MainWindowViewModel
```

### **4. XAML Bindings (Unchanged!)**

**ExplorerPage.xaml:** (Keine √Ñnderung - TreeView hat kein SelectedItem Binding)
```xaml
<TreeView ItemInvoked="SolutionTreeView_ItemInvoked"
          ItemsSource="{x:Bind ViewModel.TreeNodes, Mode=OneWay}">
```

**EditorPage.xaml:**
```xaml
<ListView ItemsSource="{x:Bind ViewModel.JourneyEditor.Journeys, Mode=OneWay}"
          SelectedItem="{x:Bind ViewModel.SelectedJourney, Mode=TwoWay}">
          <!--                   ^^^^^^^^^^^^^^^^^^^^^^^ UPDATED! -->
```

**ConfigurationPage.xaml:** (Keine √Ñnderung - bindet schon an SelectedJourney)
```xaml
<ListView ItemsSource="{Binding SelectedJourney.Stations, Mode=OneWay}"
          SelectedItem="{Binding SelectedStation, Mode=TwoWay}">
```

---

## ‚úÖ **Test-Szenarien:**

### **Szenario 1: TreeView ‚Üí Editor/Configuration**
1. **Explorer:** Journey "Hamburg ‚Üí Berlin" ausw√§hlen
2. **Editor:** Journey sollte in Journeys-Liste selected sein ‚úÖ
3. **Configuration:** Journey sollte selected sein, Stations angezeigt ‚úÖ

### **Szenario 2: Editor ‚Üí TreeView/Configuration**
1. **Editor:** Journey "M√ºnchen ‚Üí Frankfurt" in Liste klicken
2. **TreeView:** Node sollte selected sein (wenn sichtbar) ‚úÖ
3. **Configuration:** Journey sollte selected sein ‚úÖ

### **Szenario 3: Configuration ‚Üí TreeView/Editor**
1. **Configuration:** Journey ausw√§hlen
2. **TreeView:** Node sollte selected sein ‚úÖ
3. **Editor:** Journey sollte selected sein ‚úÖ

### **Szenario 4: Station Selection**
1. **TreeView:** Station unter Journey ausw√§hlen
2. **Editor:** Station sollte in Stations-Liste selected sein ‚úÖ
3. **Configuration:** Station sollte selected sein ‚úÖ

---

## üìö **Betroffene Dateien:**

### **Core ViewModel:**
- ‚úÖ `SharedUI/ViewModel/MainWindowViewModel.cs` - Added SelectedJourney, SelectedStation, SelectedWorkflow, SelectedTrain properties
- ‚úÖ `SharedUI/ViewModel/MainWindowViewModel.cs` - Updated OnNodeSelected() to set typed selections

### **Pass-Through ViewModels:**
- ‚úÖ `SharedUI/ViewModel/EditorPageViewModel.cs` - Added MainWindowViewModel parameter, pass-through properties, PropertyChanged subscription
- ‚úÖ `SharedUI/ViewModel/ProjectConfigurationPageViewModel.cs` - Added MainWindowViewModel parameter, replaced ObservableProperty with pass-through

### **DI Configuration:**
- ‚úÖ `WinUI/App.xaml.cs` - Pass MainWindowViewModel to EditorPageViewModel

### **Navigation:**
- ‚úÖ `WinUI/View/MainWindow.xaml.cs` - Pass MainWindowViewModel (ViewModel) to ProjectConfigurationPageViewModel

### **XAML Bindings:**
- ‚úÖ `WinUI/View/EditorPage.xaml` - Updated SelectedItem bindings to ViewModel.SelectedJourney/SelectedStation/SelectedWorkflow/SelectedTrain

---

## üéØ **Vorteile:**

| Vorteil | Beschreibung |
|---------|--------------|
| ‚úÖ **Single Source of Truth** | MainWindowViewModel ist die einzige Quelle f√ºr Selection-State |
| ‚úÖ **Automatische Synchronisation** | Alle Views sehen die gleiche Selection - keine manuelle Sync n√∂tig |
| ‚úÖ **MVVM-konform** | Saubere Trennung, ViewModels kommunizieren √ºber Properties |
| ‚úÖ **Testbar** | Selection-Logic ist in MainWindowViewModel zentralisiert |
| ‚úÖ **Erweiterbar** | Neue Views k√∂nnen einfach die Selection-Properties verwenden |
| ‚úÖ **Performance** | Keine Events-Kaskaden, nur PropertyChanged auf ge√§nderten Properties |

---

## üîÆ **Zuk√ºnftige Verbesserungen:**

### **Optional: Two-Way Sync f√ºr TreeView**

Aktuell: TreeView ‚Üí MainWindowViewModel (One-Way)

Zuk√ºnftig: MainWindowViewModel ‚Üí TreeView Selection (Two-Way)

**Implementation:**
```csharp
// In ExplorerPage.xaml
<TreeView SelectedItem="{x:Bind ViewModel.CurrentSelectedNode, Mode=TwoWay}">
```

**Aber:** WinUI TreeView hat kein SelectedItem Property! ‚Üí W√ºrde Custom TreeView Control erfordern

**Entscheidung:** Nicht n√∂tig - aktuelle L√∂sung funktioniert perfekt! ‚úÖ

---

## ‚úÖ **Zusammenfassung:**

**Alle Views (Explorer, Editor, Configuration) teilen sich jetzt die gleiche Selection!**

- ‚úÖ Journey ausw√§hlen ‚Üí √úberall sichtbar
- ‚úÖ Station ausw√§hlen ‚Üí √úberall sichtbar
- ‚úÖ Workflow ausw√§hlen ‚Üí √úberall sichtbar
- ‚úÖ Train ausw√§hlen ‚Üí √úberall sichtbar

**Die Architektur ist sauber, MVVM-konform, und einfach zu warten!** üé®‚ú®
