# üöÇ Copilot Instructions for MOBAflow Project

---

## üåê Communication Language

**Chat Language**: **Deutsch (German)**
- ‚úÖ All chat conversations with the user should be conducted in **German**
- ‚úÖ Technical discussions, explanations, and questions should be in **German**
- ‚úÖ Code, documentation, and comments remain in **English** (as per coding standards below)
- üí° Reason: User prefers German for natural conversation while maintaining English code for international collaboration

**Code & Documentation Language**: **English**
- ‚úÖ All code identifiers (classes, methods, variables) in **English**
- ‚úÖ All XML documentation and inline comments in **English**
- ‚úÖ README files and technical documentation in **English**
- üí° Reason: Ensures code is accessible to international developers and follows industry standards

---

## üìã Project Overview

**MOBAflow** is a model railroad control and automation system built with .NET 10.
- **Primary Platform**: Windows (WinUI 3) - Desktop application "MOBAflow"
- **Secondary Platform**: Android (MAUI) - Mobile application "MOBAsmart"
- **Target Hardware**: Z21 digital command station via UDP
- **Architecture**: Multi-project solution with shared business logic

### üöÇ Hardware Specifications

**Digital Command Station:**
- **Model**: Roco Z21 (Digital Command Station)
- **Protocol**: DCC (Digital Command and Control)
- **Power**: DC (Direct Current / Gleichstrom)
- **Communication**: UDP over local network
- **Default IP**: 192.168.0.111

**Locomotives:**
- **Decoder**: ESU Sound Decoders (each locomotive)
- **Addressing**: Each locomotive has unique DCC address

**Track Feedback System:**
- **InPorts**: Track occupancy detectors (R√ºckmeldestellen)
- **Current Setup**: 3 parallel tracks ‚Üí 3 InPorts (1, 2, 3)
- **Expandable**: System supports arbitrary number of InPorts
- **Use Case**: Count laps per track (e.g., cleaning train runs)

---

## üîå Z21 Hardware & Protocol

**Quick Reference:**
- üì° **Protocol**: UDP on port 21105
- üè† **Default IP**: 192.168.0.111
- üì¶ **Implementation**: `Backend.Z21` class
- üìÑ **Specification**: [Z21 LAN Protocol V1.13 (PDF)](https://www.z21.eu/media/Kwc_Basic_DownloadTag_Component/47-1652-959-downloadTag/default/69bad87e/1699290251/z21-lan-protokoll.pdf)
- ‚ö†Ô∏è **Thread Safety**: All events on background thread ‚Üí Use `MainThread.BeginInvokeOnMainThread()` for UI updates

### Hardware Overview
- **Model**: Roco Z21 (Digital Command Station)
- **Protocol**: DCC (Digital Command and Control)
- **Power**: DC (Direct Current / Gleichstrom)
- **Communication**: UDP over local network
- **Default IP**: 192.168.0.111

### Z21 LAN Protocol Specification
- **Protocol Type**: UDP (bidirectional)
- **Default Port**: 21105
- **Official Documentation**: [Z21 LAN Protocol Specification V1.13 (PDF)](https://www.z21.eu/media/Kwc_Basic_DownloadTag_Component/47-1652-959-downloadTag/default/69bad87e/1699290251/z21-lan-protocol.pdf)

### Key Protocol Features
1. **Command Station Control**
   - Locomotive speed, direction, and function control
   - Track power management (ON/OFF, Emergency Stop)
   - Programming mode for decoder configuration

2. **Feedback Events**
   - Track occupancy detection via InPorts
   - Real-time feedback from R-BUS modules
   - Event-driven architecture (broadcast messages)

3. **System Status Monitoring**
   - Power state (track voltage ON/OFF)
   - Short circuit detection
   - Temperature monitoring
   - Current consumption (main track, programming track)
   - Supply voltage (VCC, main power)

4. **Programming Features**
   - CV (Configuration Variable) read/write
   - Decoder programming on main track or programming track
   - DCC extended packet format support

5. **Network Discovery**
   - Broadcast address for Z21 discovery on local network
   - Keep-alive mechanism (ping every 60 seconds)
   - Multiple client support

### Implementation in MOBAflow
- **Backend Class**: `Backend.Z21` handles all protocol communication
- **Connection Management**: Async UDP client with automatic reconnection
- **Feedback Simulation**: `Z21.SimulateFeedback(inPort)` for testing without hardware
- **Thread Safety**: All Z21 events are raised on background threads ‚Üí **MainThread dispatching required for UI updates!**
- **Protocol Compliance**: All communication follows Z21 LAN Protocol Specification V1.13

### Usage Example
```csharp
// Connect to Z21
var z21 = new Backend.Z21();
await z21.ConnectAsync(IPAddress.Parse("192.168.0.111"))

// Subscribe to feedback events
z21.Received += (feedbackResult) =>
{
    MainThread.BeginInvokeOnMainThread(() =>
    {
        // Handle feedback (e.g., lap counter)
        Console.WriteLine($"InPort {feedbackResult.InPort} triggered");
    });
};

// Subscribe to system state changes
z21.OnSystemStateChanged += (systemState) =>
{
    MainThread.BeginInvokeOnMainThread(() =>
    {
        // Update UI with voltage, current, temperature
        Console.WriteLine($"Main Current: {systemState.MainCurrent} mA");
    });
};

// Control track power
await z21.SetTrackPowerOnAsync();
await z21.SetTrackPowerOffAsync();
await z21.SetEmergencyStopAsync();
```

### Important Notes
- ‚ö†Ô∏è **Z21 muss im lokalen Netzwerk sein** (192.168.x.x, 10.x.x.x oder 172.16-31.x.x)
- ‚ö†Ô∏è **Alle Z21-Ereignisse werden im UDP-Hintergrundthread ausgel√∂st** ‚Üí Verwenden Sie `MainThread.BeginInvokeOnMainThread()` f√ºr UI-Updates
- ‚úÖ **Verbindung wird √ºber UDP verwaltet** (kein TCP, kein HTTP)
- ‚úÖ **Protokoll ist gut dokumentiert** ‚Üí Konsultieren Sie das PDF zur Implementierung neuer Befehle
- ‚úÖ **Simulationsmodus verf√ºgbar** zum Testen ohne Hardware

---

## üéØ Mandatory Pre-Flight Checks

**BEFORE implementing ANY feature request, you MUST:**

### 1. Technology Feasibility Check
- ‚úÖ **Search Microsoft Learn** for official documentation on the requested feature
- ‚úÖ **Check for known issues** in .NET 10 / MAUI 10 / WinUI 3 / related technologies
- ‚úÖ **Verify stability** of the approach in the current .NET version
- ‚úÖ **Verify Visual Studio 2026 (18.x)** is being used for full `net10.0` support
- ‚úÖ **Propose alternatives** if the technology is unstable or problematic
- ‚ö†Ô∏è **MAUI Foreground Services** remain problematic ‚Üí suggest native Android implementation

### 2. Communicate Findings
- üì¢ **Present your analysis** to the user BEFORE writing code
- ‚ö†Ô∏è **Highlight risks** (e.g., "MAUI Foreground Services are unstable in .NET 10 Final")
- üí° **Suggest alternatives** if the requested approach has issues
- ‚úÖ **Wait for explicit approval** before proceeding with implementation

### 3. Decision Gate
```
IF (technology is stable AND documented AND appropriate)
    THEN implement
ELSE
    PROPOSE alternatives AND wait for user decision
```

---

## üèóÔ∏è Solution Architecture

### Project Structure

| Project | Purpose | Target Framework | Key Dependencies |
|---------|---------|------------------|------------------|
| **Backend** | Z21 communication, model railroad logic | `net10.0` | SignalR, Newtonsoft.Json |
| **SharedUI** | MVVM ViewModels, shared UI logic | `net10.0` | CommunityToolkit.Mvvm |
| **WinUI** | Windows desktop application "MOBAflow" | `net10.0-windows10.0.17763.0` | WindowsAppSDK, Microsoft.Extensions.DependencyInjection |
| **MAUI** | Android mobile application "MOBAsmart" | `net10.0-android36.0` | Microsoft.Maui.Controls, CommunityToolkit.Mvvm, UraniumUI.Material |
| **Sound** | Audio/TTS functionality | `net10.0` | Microsoft.CognitiveServices.Speech, System.Speech |
| **Test** | Unit tests | `net10.0` | NUnit, NUnit3TestAdapter |

### Dependency Flow
```
WinUI ‚Üí SharedUI ‚Üí Backend ‚Üí Sound
MAUI ‚Üí SharedUI ‚Üí Backend
Test ‚Üí Backend
```

### Root Namespace
- **All projects**: `Moba.Smart` (with sub-namespaces as appropriate)

---

## üé® Architectural Patterns (MANDATORY)

### 0. Code Organization: One Class Per File
- ‚úÖ **ALWAYS** create a separate file for each class
- ‚úÖ **File name** must match the class name (e.g., `SystemState.cs` for `SystemState` class)
- ‚úÖ **Exception**: Small, tightly-coupled helper classes (e.g., DTOs, records) may share a file if they form a logical unit
- ‚úÖ **Nested classes**: Avoid unless absolutely necessary (e.g., private implementation details)
- ‚ùå **NEVER** put multiple public classes in one file
- üí° **Reason**: Improves discoverability, maintainability, and follows .NET conventions

**Example (CORRECT):**
```
Backend/
  ‚îú‚îÄ‚îÄ Z21.cs              // Z21 class
  ‚îú‚îÄ‚îÄ SystemState.cs      // SystemState class
  ‚îî‚îÄ‚îÄ FeedbackResult.cs   // FeedbackResult class
```

**Example (WRONG):**
```
Backend/
  ‚îî‚îÄ‚îÄ Z21.cs  // Contains Z21, SystemState, AND FeedbackResult ‚ùå
```

### 1. MVVM Pattern
- ‚úÖ **ALL UI logic** must be in ViewModels (never in code-behind)
- ‚úÖ Use **CommunityToolkit.Mvvm** (`ObservableObject`, `RelayCommand`, `ObservableProperty`)
- ‚úÖ ViewModels must be **testable** (no direct UI dependencies)
- ‚ùå **NEVER** put business logic in Views (`.xaml.cs` should be minimal)

**Example:**
```csharp
public partial class MyViewModel : ObservableObject
{
    [ObservableProperty]
    private string title = "Default";

    [RelayCommand]
    private async Task DoSomethingAsync()
    {
        // Logic here
    }
}
```

### 2. Dependency Injection
- ‚úÖ Use **Microsoft.Extensions.DependencyInjection** (.NET ServiceProvider)
- ‚úÖ Register services in `App.xaml.cs` ‚Üí `ConfigureServices()` or `MauiProgram.cs`
- ‚úÖ Services: **Singleton** for shared state (e.g., `IIoService`)
- ‚úÖ ViewModels/Views: **Transient** (new instance per request)
- ‚úÖ Inject dependencies via **constructor injection**

**Example (from MauiProgram.cs):**
```csharp
builder.Services.AddSingleton<IIoService, IoService>();
builder.Services.AddTransient<MainViewModel>();
builder.Services.AddTransient<MainPage>();
```

### 3. Service Locator Pattern
- ‚ùå **AVOID** service locator pattern (e.g., `ServiceProvider.GetService()` in ViewModels)
- ‚úÖ Always use **constructor injection**
- ‚úÖ Only exception: `App.xaml.cs` / `MauiProgram.cs` can use `GetRequiredService()` for root window/page creation

### 4. Separation of Concerns
- **Backend**: Pure C# business logic (no UI dependencies)
- **SharedUI**: ViewModels + UI-agnostic logic (no MAUI/WinUI dependencies)
- **WinUI**: Views (XAML) + minimal code-behind
- **MAUI**: Views (XAML) + minimal code-behind
- **Sound**: Audio/TTS features (isolated)

---

## üõ†Ô∏è Technology Constraints

### .NET 10 LTS (Long-Term Support)
- ‚úÖ **.NET 10 is now FINAL** (released May 20, 2025 - 3 years LTS support, production-ready)
- ‚úÖ **Visual Studio 2026 (18.x)** required for full `net10.0` targeting and tooling support
- ‚úÖ Use **latest C# 13 features** where appropriate
- ‚úÖ Leverage **primary constructors** for DI
- ‚ùå Avoid experimental/preview features unless explicitly requested

### Visual Studio Requirements
- ‚úÖ **Visual Studio 2026 (18.x)**: Full support for `net10.0` targeting, Android API 36, and MAUI 10 tooling
- üí° **Recommendation**: Always use Visual Studio 2026 for this project

### WinUI 3
- ‚úÖ Use **Windows App SDK** (WindowsAppSDK package)
- ‚úÖ Target **Windows 10.0.17763.0** minimum
- ‚úÖ Use **x:Bind** over **Binding** for performance
- ‚ö†Ô∏è WinUI 3 has **limited community support** - check official docs carefully

### WinUI 3 Tooling Limitations (2025)
- ‚ö†Ô∏è **No XAML Designer**: Visual Studio 2022/2026 does not support WinUI 3 XAML designer
  - **Workaround**: Use **XAML Hot Reload** for live preview while app is running
  - **Alternative**: Use **XAML Live Preview** (limited support in VS 2022 17.1+)
- ‚úÖ **IntelliSense**: Works in XAML editor (improved since early previews)
- ‚úÖ **Hot Reload**: Fully supported for WinUI 3 apps
- ‚ö†Ô∏è **Window lifecycle**: Manual management required ‚Üí Handle in `App.xaml.cs`
- ‚ö†Ô∏è **File I/O**: Use `Windows.Storage` APIs for UWP compatibility

### MAUI 10 (Final Release)
- ‚úÖ **Production-ready** for standard mobile apps
- ‚úÖ **Stable**: CollectionView, CarouselView, Navigation, Layouts
- ‚úÖ **Android 16 (API 36)**: Stable (Beta 3, final release expected summer 2025)
- ‚úÖ **Recommended Minimum API**: 24 (Nougat) to avoid desugaring crashes with Java default interface methods
- ‚ö†Ô∏è **Known Issues** (still present in final release):
  - **Foreground Services**: Unstable ‚Üí Use native Android implementation if needed
  - **Shell Navigation**: Can be problematic with complex scenarios ‚Üí Prefer `NavigationPage` for simple apps
  - **Hot Reload with Source Generators**: May not update `ObservableProperty` changes ‚Üí Restart debugger
- ‚ö†Ô∏è **Threading Rules UNCHANGED**: MainThread dispatching still required! (See "MAUI Threading" section)

### MAUI 10 Improvements (Final Release)
- ‚úÖ **CollectionView/CarouselView**: New handlers are now default (better performance and stability)
- ‚úÖ **dotnet run support**: Can now run Android projects via CLI with `-p:AdbTarget`
- ‚úÖ **Marshal methods**: Enabled by default (startup performance boost)
  - If startup hangs occur, disable with `<AndroidEnableMarshalMethods>false</AndroidEnableMarshalMethods>`
- ‚úÖ **JDK 21 support**: Can build Android projects with JDK 21
- ‚úÖ **RefreshView.IsRefreshEnabled**: New property for better control (distinct from IsEnabled)
- ‚úÖ **SearchBar.SearchIconColor**: Customizable search icon color
- ‚úÖ **SearchBar.ReturnType**: Specifies return button appearance (default: Search)
- ‚úÖ **Switch.OffColor**: Customize switch off-state color
- ‚úÖ **HybridWebView.InvokeJavaScriptAsync**: New overload for void-returning JavaScript methods
- ‚úÖ **Editor/Entry on Android**: Now use `MauiAppCompatEditText` with `SelectionChanged` event support
- ‚ö†Ô∏è **TableView**: Deprecated ‚Üí Use CollectionView instead
- ‚ö†Ô∏è **Accelerator**: Removed ‚Üí Use KeyboardAccelerator instead
- ‚ö†Ô∏è **ClickGestureRecognizer**: Removed ‚Üí Use TapGestureRecognizer instead

### MAUI 10 Android Theme Configuration (CRITICAL!)
‚ö†Ô∏è **UraniumUI.Material requires Material Components Theme!**

**Problem:** 
- UraniumUI.Material components (TextInputLayout, etc.) require `Theme.MaterialComponents` parent theme
- Default MAUI projects only have `Maui.SplashTheme` ‚Üí Crash: "This component requires that you specify a valid TextAppearance attribute"

**Solution:**
1. Create `Platforms/Android/Resources/values/styles.xml`:
```xml
<style name="MainTheme" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
    <!-- Material Components configuration -->
</style>
<style name="Maui.SplashTheme" parent="MainTheme">
    <!-- Splash screen configuration -->
</style>
```

2. Create `Platforms/Android/Resources/values/colors.xml`:
```xml
<color name="colorPrimary">#2c3e50</color>
<color name="colorPrimaryDark">#1a252f</color>
<color name="colorAccent">#3498db</color>
```

3. Update `MainActivity.cs`:
```csharp
protected override void OnCreate(Bundle? savedInstanceState)
{
    base.OnCreate(savedInstanceState);
    SetTheme(Resource.Style.MainTheme); // Switch to Material Theme
}
```

4. Add to `.csproj`:
```xml
<ItemGroup>
    <AndroidResource Include="Platforms\Android\Resources\**\*.xml" />
</ItemGroup>
```

**Files Required:**
- `Platforms/Android/Resources/values/styles.xml` ‚úÖ
- `Platforms/Android/Resources/values/colors.xml` ‚úÖ
- Updated `MainActivity.cs` with `SetTheme()` ‚úÖ

---

## üìö Documentation Sources (Use These First!)

### Primary Sources
1. **Microsoft Learn** - Official .NET / MAUI / WinUI documentation
   - https://learn.microsoft.com/dotnet/
   - https://learn.microsoft.com/dotnet/maui/
   - https://learn.microsoft.com/windows/apps/winui/

2. **GitHub Issues**
   - .NET MAUI: https://github.com/dotnet/maui/issues
   - WinUI: https://github.com/microsoft/microsoft-ui-xaml/issues
   - .NET: https://github.com/dotnet/runtime/issues

3. **NuGet Package Docs**
   - CommunityToolkit.Mvvm: https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/
   - CommunityToolkit.Maui: https://learn.microsoft.com/dotnet/communitytoolkit/maui/
   - UraniumUI: https://enisn-projects.io/docs/en/uranium/latest/

4. **Z21 Protocol Documentation**
   - See dedicated **"Z21 Hardware & Protocol"** section above for complete documentation
   - Official PDF: [Z21 LAN Protocol Specification V1.13](https://www.z21.eu/media/Kwc_Basic_DownloadTag_Component/47-1652-959-downloadTag/default/69bad87e/1699290251/z21-lan-protokoll.pdf)

### Search Strategy
```
1. Search Microsoft Learn first (for .NET/MAUI/WinUI)
2. Check GitHub issues for known problems
3. Search and check stackoverflow.com
4. Verify with NuGet package documentation
5. Consult Z21 Protocol PDF for hardware communication details
6. Present important findings to user BEFORE coding
```

---

## üö® Known Issues & Workarounds

### .NET 10 Final Known Issues
- ‚ö†Ô∏è **MAUI Android Foreground Services**: Still unstable in final release ‚Üí Use native Android implementation
- ‚ö†Ô∏è **MAUI Shell Navigation**: Can be problematic with lifecycle issues ‚Üí Prefer `NavigationPage` for simpler navigation scenarios
- ‚ö†Ô∏è **Hot Reload with Source Generators**: `ObservableProperty` changes may not update in running app ‚Üí Restart debugger to see changes
- ‚ö†Ô∏è **Marshal Methods Startup Hangs**: If app hangs on startup, disable marshal methods:
  ```xml
  <PropertyGroup>
      <AndroidEnableMarshalMethods>false</AndroidEnableMarshalMethods>
  </PropertyGroup>
  ```
  - If this fixes the issue, please report to: https://github.com/dotnet/android/issues

---

## üßµ MAUI Threading (CRITICAL!)

‚ö†Ô∏è **IMPORTANT**: MAUI has strict threading requirements on mobile platforms (Android, iOS)!

### **The Golden Rule:**
**Only the Main Thread (UI Thread) can modify UI properties!**

| Thread Type | Can Modify UI? | Example |
|-------------|----------------|---------|
| **Main Thread (UI Thread)** | ‚úÖ YES | `stat.Count++` (if `Count` is `ObservableProperty`) |
| **Background Thread** | ‚ùå NO ‚Üí CRASH | Network callbacks, UDP events, timers |

### **Common Crash Scenarios:**

**‚ùå BAD: Background thread modifying ObservableProperty**
```csharp
// Called from UDP callback (background thread)
private void OnDataReceived(Data data)
{
    StatusText = "Received!";  // ‚ùå CRASH: Android Looper error!
    Items.Add(data);            // ‚ùå CRASH: ObservableCollection not thread-safe!
}
```

**‚úÖ GOOD: Dispatch to Main Thread**
```csharp
private void OnDataReceived(Data data)
{
    // ‚úÖ Dispatch all UI updates to Main Thread
#if ANDROID || IOS || MACCATALYST || WINDOWS
    MainThread.BeginInvokeOnMainThread(() =>
    {
        StatusText = "Received!";  // ‚úÖ Safe on UI thread
        Items.Add(data);            // ‚úÖ Safe on UI thread
    });
#else
    // Fallback for unit tests
    StatusText = "Received!";
    Items.Add(data);
#endif
}
```

### **When to Use MainThread Dispatching:**

| Scenario | Requires Dispatch? |
|----------|-------------------|
| **Network callbacks** (UDP, TCP, HTTP) | ‚úÖ YES |
| **Timer callbacks** (`System.Timers.Timer`) | ‚úÖ YES |
| **Background tasks** (`Task.Run`) | ‚úÖ YES |
| **Event handlers** (button clicks) | ‚ùå NO (already on UI thread) |
| **ViewModel constructors** | ‚ùå NO (already on UI thread) |

### **Error Signatures (Android):**

```
‚ùå RuntimeException: Can't create handler inside thread that has not called Looper.prepare()
‚ùå IllegalStateException: This collection cannot be modified from a background thread
‚ùå CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views
```

**Solution:** Wrap UI updates in `MainThread.BeginInvokeOnMainThread(() => { ... })`

### **Best Practices:**

1. **Identify Background Threads:**
   - Network callbacks (UDP, TCP, SignalR)
   - Timer events (`System.Timers.Timer`)
   - `Task.Run()` continuations

2. **Dispatch UI Updates:**
```csharp
#if ANDROID || IOS || MACCATALYST || WINDOWS
    MainThread.BeginInvokeOnMainThread(() =>
    {
        // UI updates here
    });
#else
    // Fallback for unit tests
#endif
```

3. **Keep Non-UI Work Off Main Thread:**
```csharp
private void OnDataReceived(Data data)
{
    // ‚úÖ Heavy processing on background thread
    var processed = ProcessData(data);
    
    // ‚úÖ UI update on main thread
    MainThread.BeginInvokeOnMainThread(() =>
    {
        StatusText = $"Processed: {processed}";
    });
}
```

4. **Don't Block UI Thread:**
```csharp
// ‚ùå BAD: Blocks UI thread
MainThread.InvokeOnMainThreadAsync(async () =>
{
    await Task.Delay(5000);  // UI frozen for 5 seconds!
}).Wait();

// ‚úÖ GOOD: Async dispatch
MainThread.BeginInvokeOnMainThread(() =>
{
    // Quick UI update only
});
```

### **Platform Differences:**

| Platform | Threading Model | Strictness |
|----------|----------------|------------|
| **Android** | **Looper-based** | ‚ö†Ô∏è **VERY STRICT** (crashes immediately) |
| **iOS** | **RunLoop-based** | ‚ö†Ô∏è **VERY STRICT** (crashes immediately) |
| **Windows** | **Dispatcher-based** | ‚ö†Ô∏è **Moderate** (may allow, but unreliable) |
| **Unit Tests** | **None** | ‚úÖ **Lenient** (no UI thread enforcement) |

### **Real-World Example: Z21 UDP Callback**

```csharp
// Backend.Z21 raises event on UDP thread
_z21.Received += OnFeedbackReceived;

// ‚ùå WRONG: Direct UI update
private void OnFeedbackReceived(Backend.FeedbackResult result)
{
    stat.Count++;  // ‚ùå CRASH on Android!
}

// ‚úÖ CORRECT: Dispatched UI update
private void OnFeedbackReceived(Backend.FeedbackResult result)
{
#if ANDROID || IOS || MACCATALYST || WINDOWS
    MainThread.BeginInvokeOnMainThread(() =>
    {
        var stat = Statistics.FirstOrDefault(s => s.InPort == result.InPort);
        if (stat != null)
        {
            stat.Count++;  // ‚úÖ Safe on UI thread
        }
    });
#else
    // Unit test fallback
    var stat = Statistics.FirstOrDefault(s => s.InPort == result.InPort);
    if (stat != null) stat.Count++;
#endif
}
```

### **Debugging Tips:**

1. **Enable Thread Names:**
```csharp
System.Diagnostics.Debug.WriteLine($"Thread: {Thread.CurrentThread.ManagedThreadId}");
```

2. **Check If On Main Thread:**
```csharp
if (!MainThread.IsMainThread)
{
    throw new InvalidOperationException("Must be called on UI thread!");
}
```

3. **Android LogCat Filter:**
```bash
adb logcat | grep -E "Looper|CalledFromWrongThread|RuntimeException"
```

### **Related Guidelines:**
- See **Async/Await Guidelines** (below) for async patterns
- See **MVVM Pattern** for ObservableProperty threading
- See **Known Issues & Workarounds** for other known .NET 10 / MAUI 10 problems

---

# üöÄ Advanced Async/Await Usage Guidelines

## ‚ùì When to Use Async

- **Use Async for I/O-bound work**: Any operation that involves network, file, or database should be async.
- **Avoid Async for CPU-bound work**: If your method is doing heavy computations, keep it synchronous or offload to a background thread.

## üìá Async Method Naming

- **Suffix with `Async`**: This is crucial for differentiating between sync and async methods at a glance.
- **Example**: For a method that fetches data, use `FetchDataAsync` instead of `FetchData`.

## üö´ Anti-Patterns to Avoid

1. **Async Overhead for Simple Tasks**: Don't make simple property getters/setters async. It's unnecessary and adds overhead.
    ```csharp
    // ‚ùå BAD: Overusing async
    public async Task<int> GetNumberAsync() => await Task.FromResult(_number);
    ```
   
2. **Blocking on Async Code**: Avoid using `.Result` or `.Wait()` on tasks. It can cause deadlocks, especially in UI applications.
    ```csharp
    // ‚ùå BAD: Blocking async code
    var data = LoadDataAsync().Result; // Potential deadlock!
    ```

3. **Fire-and-Forget**: If you must fire-and-forget, at least log the exceptions in the async method.
    ```csharp
    // ‚ùå BAD: Ignoring exceptions
    public void Start() { _ = DoWorkAsync(); }
    
    // ‚úÖ GOOD: Handle exceptions
    public void Start()
    {
        _ = Task.Run(async () =>
        {
            try { await DoWorkAsync(); }
            catch (Exception ex) { _logger.LogError(ex, "Error in DoWorkAsync"); }
        });
    }
    ```

4. **Async Void**: This should be avoided except for event handlers. It makes error handling and testing difficult.
    ```csharp
    // ‚ùå BAD: Async void method
    public async void OnButtonClick()
    {
        await DoSomethingAsync(); // If this fails, it's hard to know!
    }
    ```

## ‚è≥ Task.Run() Usage

- **Offload CPU-bound work**: If you have a synchronous method that is CPU-intensive, wrap it in `Task.Run()` to run it on a background thread.
    ```csharp
    public void ProcessData()
    {
        Task.Run(() =>
        {
            // CPU-intensive work here
        });
    }
    ```

## üîó Configuring Await

- **Use `ConfigureAwait(false)`** in library or backend code where you don't need the context (like UI context).
- **Don't use it in UI code**: Your ViewModels and Views usually need the UI context to update bindings.

    ```csharp
    // ‚úÖ GOOD: Library code (Backend, SharedUI without UI updates)
    public async Task<Data> LoadDataAsync()
    {
        var content = await File.ReadAllTextAsync(path).ConfigureAwait(false);
        return Parse(content);
    }
    
    // ‚ùå BAD: UI code (MAUI ViewModels)
    public async Task LoadAsync()
    {
        var data = await _service.LoadDataAsync().ConfigureAwait(false); // Don't do this!
        Items = new ObservableCollection<Item>(data); // Needs UI thread
    }
    ```

## üìÇ IAsyncEnumerable for Streaming Data

- **Use `IAsyncEnumerable<T>` for methods that return a stream of data**: This is especially useful for paging or continuous data feeds.
    ```csharp
    public async IAsyncEnumerable<int> GetNumbersAsync([EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        for (int i = 0; i < 10; i++)
        {
            await Task.Delay(1000, cancellationToken); // Simulate async work
            yield return i;
        }
    }
    ```

## ‚úîÔ∏è Error Handling in Async

- **Always use try-catch around await**: This is crucial for logging and handling exceptions in async methods.
- **Rethrow exceptions** after logging if you want the caller to handle them.

    ```csharp
    public async Task ConnectAsync()
    {
        try
        {
            await _z21.ConnectAsync();
        }
        catch (SocketException ex)
        {
            _logger.LogError(ex, "Z21 connection failed");
            StatusText = $"Connection failed: {ex.Message}";
            throw; // Important: Rethrow the exception
        }
    }
    ```

## ‚úîÔ∏è Best Practices Checklist

- [ ] **All I/O operations use async/await?**
- [ ] **No async void methods except for event handlers?**
- [ ] **Methods that don't need the context use ConfigureAwait(false)?**
- [ ] **No deadlocks caused by blocking on async code?**
- [ ] **Fire-and-forget tasks have exception handling?**
- [ ] **Async methods have proper naming (`Async` suffix)?**
- [ ] **IAsyncEnumerable used for streaming data when appropriate?**
