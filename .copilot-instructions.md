# ğŸš‚ Copilot Instructions for MOBAflow Project

---

## ğŸŒ Communication Language

**Chat Language**: **Deutsch (German)**
- âœ… All chat conversations with the user should be conducted in **German**
- âœ… Technical discussions, explanations, and questions should be in **German**
- âœ… Code, documentation, and comments remain in **English** (as per coding standards below)
- ğŸ’¡ Reason: User prefers German for natural conversation while maintaining English code for international collaboration

**Code & Documentation Language**: **English**
- âœ… All code identifiers (classes, methods, variables) in **English**
- âœ… All XML documentation and inline comments in **English**
- âœ… README files and technical documentation in **English**
- ğŸ’¡ Reason: Ensures code is accessible to international developers and follows industry standards

---

## ğŸ“‹ Project Overview

**MOBAflow** is a model railroad control and automation system built with .NET 10.
- **Primary Platform**: Windows (WinUI 3) - Desktop application "MOBAflow"
- **Secondary Platform**: Android (MAUI) - Mobile application "MOBAsmart"
- **Target Hardware**: Z21 digital command station via UDP
- **Architecture**: Multi-project solution with shared business logic

### ğŸš‚ Hardware Specifications

**Digital Command Station:**
- **Model**: Roco Z21 (Digital Command Station)
- **Protocol**: DCC (Digital Command and Control)
- **Power**: DC (Direct Current / Gleichstrom)
- **Communication**: UDP over local network
- **Default IP**: 192.168.0.111

**Locomotives:**
- **Decoder**: ESU Sound Decoders (each locomotive)
- **Addressing**: Each locomotive has unique DCC address

**Track Feedback System:**
- **InPorts**: Track occupancy detectors (RÃ¼ckmeldestellen)
- **Current Setup**: 3 parallel tracks â†’ 3 InPorts (1, 2, 3)
- **Expandable**: System supports arbitrary number of InPorts
- **Use Case**: Count laps per track (e.g., cleaning train runs)

**Z21 LAN Protocol:**
- **Protocol Type**: UDP (bidirectional)
- **Default Port**: 21105
- **Documentation**: [Z21 LAN Protocol Specification (PDF)](https://www.z21.eu/media/Kwc_Basic_DownloadTag_Component/47-1652-959-downloadTag/default/69bad87e/1699290251/z21-lan-protokoll.pdf)
- **Key Features**:
  - Command Station Control (locomotive speed, direction, functions)
  - Feedback Events (track occupancy detection)
  - System Status (power state, short circuit detection)
  - Programming (CV read/write for decoders)
- **Implementation**: `Backend.Z21` class handles all protocol communication

---

## ğŸ¯ Mandatory Pre-Flight Checks

**BEFORE implementing ANY feature request, you MUST:**

### 1. Technology Feasibility Check
- âœ… **Search Microsoft Learn** for official documentation on the requested feature
- âœ… **Check for known issues** in .NET 10 / WinUI 3 / related technologies
- âœ… **Verify stability** of the approach in the current .NET version
- âœ… **Propose alternatives** if the technology is unstable or problematic

### 2. Communicate Findings
- ğŸ“¢ **Present your analysis** to the user BEFORE writing code
- âš ï¸ **Highlight risks** (e.g., "MAUI Foreground Services are unstable in .NET 10 RC")
- ğŸ’¡ **Suggest alternatives** if the requested approach has issues
- âœ… **Wait for explicit approval** before proceeding with implementation

### 3. Decision Gate
```
IF (technology is stable AND documented AND appropriate)
    THEN implement
ELSE
    PROPOSE alternatives AND wait for user decision
```

---

## ğŸ—ï¸ Solution Architecture

### Project Structure

| Project | Purpose | Target Framework | Key Dependencies |
|---------|---------|------------------|------------------|
| **Backend** | Z21 communication, model railroad logic | `net10.0` | SignalR, Newtonsoft.Json |
| **SharedUI** | MVVM ViewModels, shared UI logic | `net10.0` | CommunityToolkit.Mvvm |
| **WinUI** | Windows desktop application "MOBAflow" | `net10.0-windows10.0.17763.0` | WindowsAppSDK, Microsoft.Extensions.DependencyInjection |
| **MAUI** | Android mobile application "MOBAsmart" | `net10.0-android` | Microsoft.Maui.Controls, CommunityToolkit.Mvvm |
| **Sound** | Audio/TTS functionality | `net10.0` | Microsoft.CognitiveServices.Speech, System.Speech |
| **Test** | Unit tests | `net10.0` | NUnit, NUnit3TestAdapter |

### Dependency Flow
```
WinUI â†’ SharedUI â†’ Backend â†’ Sound
MAUI â†’ SharedUI â†’ Backend
Test â†’ Backend
```

### Root Namespace
- **All projects**: `Moba.Smart` (with sub-namespaces as appropriate)

---

## ğŸ¨ Architectural Patterns (MANDATORY)

### 1. MVVM Pattern
- âœ… **ALL UI logic** must be in ViewModels (never in code-behind)
- âœ… Use **CommunityToolkit.Mvvm** (`ObservableObject`, `RelayCommand`, `ObservableProperty`)
- âœ… ViewModels must be **testable** (no direct UI dependencies)
- âŒ **NEVER** put business logic in Views (`.xaml.cs` should be minimal)

**Example:**
```csharp
public partial class MyViewModel : ObservableObject
{
    [ObservableProperty]
    private string title = "Default";

    [RelayCommand]
    private async Task DoSomethingAsync()
    {
        // Logic here
    }
}
```

### 2. Dependency Injection
- âœ… Use **Microsoft.Extensions.DependencyInjection** (.NET ServiceProvider)
- âœ… Register services in `App.xaml.cs` â†’ `ConfigureServices()`
- âœ… Services: **Singleton** for shared state (e.g., `IIoService`)
- âœ… ViewModels/Views: **Transient** (new instance per request)
- âœ… Inject dependencies via **constructor injection**

**Example (from App.xaml.cs):**
```csharp
private static void ConfigureServices(IServiceCollection services)
{
    // Singleton services
    services.AddSingleton<IIoService, IoService>();
    
    // Transient ViewModels
    services.AddTransient<MainWindowViewModel>();
    
    // Transient Views
    services.AddTransient<MainWindow>();
}
```

### 3. Service Locator Pattern
- âŒ **AVOID** service locator pattern (e.g., `ServiceProvider.GetService()` in ViewModels)
- âœ… Always use **constructor injection**
- âœ… Only exception: `App.xaml.cs` can use `GetRequiredService()` for root window creation

### 4. Separation of Concerns
- **Backend**: Pure C# business logic (no UI dependencies)
- **SharedUI**: ViewModels + UI-agnostic logic
- **WinUI**: Views (XAML) + minimal code-behind
- **Sound**: Audio/TTS features (isolated)

---

## ğŸ› ï¸ Technology Constraints

### .NET 10 Specific
- âœ… Use **latest C# 13 features** where appropriate
- âœ… Leverage **primary constructors** for DI
- âš ï¸ **CAUTION**: .NET 10 is still **Release Candidate** - prefer stable, proven solutions
- âŒ Avoid experimental/preview features unless explicitly requested

### WinUI 3
- âœ… Use **Windows App SDK** (WindowsAppSDK package)
- âœ… Target **Windows 10.0.17763.0** minimum
- âœ… Use **x:Bind** over **Binding** for performance
- âš ï¸ WinUI 3 has **limited community support** - check official docs carefully

### MAUI / Xamarin
- âŒ **DO NOT suggest MAUI** for Android unless explicitly requested
- âš ï¸ MAUI in .NET 10 has **known issues** with:
  - Foreground Services
  - Fragment navigation
  - Material Design themes
- ğŸ’¡ **Prefer native Android** (Kotlin/Java) if mobile is required

### Z21 Communication
- âœ… Z21 uses **UDP protocol** (backend handles this)
- âœ… Connection management via `Backend.Z21` class
- âœ… Feedback simulation available via `Z21.SimulateFeedback(inPort)`
- ğŸ“„ **Protocol Documentation**: [Z21 LAN Protocol](https://www.z21.eu/media/Kwc_Basic_DownloadTag_Component/47-1652-959-downloadTag/default/69bad87e/1699290251/z21-lan-protokoll.pdf)
  - Bidirectional UDP communication
  - Command and feedback messages
  - Port: 21105 (default)
  - Broadcast address for Z21 discovery

---

## ğŸ“š Documentation Sources (Use These First!)

### Primary Sources
1. **Microsoft Learn** - Official .NET / WinUI documentation
   - https://learn.microsoft.com/dotnet/
   - https://learn.microsoft.com/windows/apps/winui/

2. **GitHub Issues**
   - .NET MAUI: https://github.com/dotnet/maui/issues
   - WinUI: https://github.com/microsoft/microsoft-ui-xaml/issues
   - .NET: https://github.com/dotnet/runtime/issues

3. **NuGet Package Docs**
   - CommunityToolkit.Mvvm: https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/

4. **Z21 Protocol Documentation**
   - Official Z21 LAN Protocol: https://www.z21.eu/media/Kwc_Basic_DownloadTag_Component/47-1652-959-downloadTag/default/69bad87e/1699290251/z21-lan-protokoll.pdf
   - Use this for implementing new Z21 commands or debugging communication issues
   - All Z21 communication must follow this specification

### Search Strategy
```
1. Search Microsoft Learn first (for .NET/MAUI/WinUI)
2. Check GitHub issues for known problems
3. Verify with NuGet package documentation
4. Consult Z21 Protocol PDF for hardware communication details
5. Present findings to user BEFORE coding
```

---

## ğŸš¨ Known Issues & Workarounds

### .NET 10 RC Issues
- âš ï¸ **MAUI Android**: Foreground services unstable â†’ Use native Android or WinUI only
- âš ï¸ **MAUI Navigation**: Fragment errors common â†’ Avoid Shell/NavigationPage
- âš ï¸ **Hot Reload**: May cause app hangs â†’ Restart debugger if issues occur

### WinUI 3 Limitations
- âš ï¸ **Design-time support**: Limited IntelliSense in XAML â†’ Use compiled bindings (`x:Bind`)
- âš ï¸ **Window lifecycle**: Manual management required â†’ Handle in `App.xaml.cs`
- âš ï¸ **File I/O**: Use `Windows.Storage` APIs for UWP compatibility

---

## ğŸ§µ MAUI Threading (CRITICAL!)

âš ï¸ **IMPORTANT**: MAUI has strict threading requirements on mobile platforms (Android, iOS)!

### **The Golden Rule:**
**Only the Main Thread (UI Thread) can modify UI properties!**

| Thread Type | Can Modify UI? | Example |
|-------------|----------------|---------|
| **Main Thread (UI Thread)** | âœ… YES | `stat.Count++` (if `Count` is `ObservableProperty`) |
| **Background Thread** | âŒ NO â†’ CRASH | Network callbacks, UDP events, timers |

### **Common Crash Scenarios:**

**âŒ BAD: Background thread modifying ObservableProperty**
```csharp
// Called from UDP callback (background thread)
private void OnDataReceived(Data data)
{
    StatusText = "Received!";  // âŒ CRASH: Android Looper error!
    Items.Add(data);            // âŒ CRASH: ObservableCollection not thread-safe!
}
```

**âœ… GOOD: Dispatch to Main Thread**
```csharp
private void OnDataReceived(Data data)
{
    // âœ… Dispatch all UI updates to Main Thread
#if ANDROID || IOS || MACCATALYST || WINDOWS
    MainThread.BeginInvokeOnMainThread(() =>
    {
        StatusText = "Received!";  // âœ… Safe on UI thread
        Items.Add(data);            // âœ… Safe on UI thread
    });
#else
    // Fallback for unit tests
    StatusText = "Received!";
    Items.Add(data);
#endif
}
```

### **When to Use MainThread Dispatching:**

| Scenario | Requires Dispatch? |
|----------|-------------------|
| **Network callbacks** (UDP, TCP, HTTP) | âœ… YES |
| **Timer callbacks** (`System.Timers.Timer`) | âœ… YES |
| **Background tasks** (`Task.Run`) | âœ… YES |
| **Event handlers** (button clicks) | âŒ NO (already on UI thread) |
| **ViewModel constructors** | âŒ NO (already on UI thread) |

### **Error Signatures (Android):**

```
âŒ RuntimeException: Can't create handler inside thread that has not called Looper.prepare()
âŒ IllegalStateException: This collection cannot be modified from a background thread
âŒ CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views
```

**Solution:** Wrap UI updates in `MainThread.BeginInvokeOnMainThread(() => { ... })`

### **Best Practices:**

1. **Identify Background Threads:**
   - Network callbacks (UDP, TCP, SignalR)
   - Timer events (`System.Timers.Timer`)
   - `Task.Run()` continuations

2. **Dispatch UI Updates:**
```csharp
#if ANDROID || IOS || MACCATALYST || WINDOWS
    MainThread.BeginInvokeOnMainThread(() =>
    {
        // UI updates here
    });
#else
    // Fallback for unit tests
#endif
```

3. **Keep Non-UI Work Off Main Thread:**
```csharp
private void OnDataReceived(Data data)
{
    // âœ… Heavy processing on background thread
    var processed = ProcessData(data);
    
    // âœ… UI update on main thread
    MainThread.BeginInvokeOnMainThread(() =>
    {
        StatusText = $"Processed: {processed}";
    });
}
```

4. **Don't Block UI Thread:**
```csharp
// âŒ BAD: Blocks UI thread
MainThread.InvokeOnMainThreadAsync(async () =>
{
    await Task.Delay(5000);  // UI frozen for 5 seconds!
}).Wait();

// âœ… GOOD: Async dispatch
MainThread.BeginInvokeOnMainThread(() =>
{
    // Quick UI update only
});
```

### **Platform Differences:**

| Platform | Threading Model | Strictness |
|----------|----------------|------------|
| **Android** | **Looper-based** | âš ï¸ **VERY STRICT** (crashes immediately) |
| **iOS** | **RunLoop-based** | âš ï¸ **VERY STRICT** (crashes immediately) |
| **Windows** | **Dispatcher-based** | âš ï¸ **Moderate** (may allow, but unreliable) |
| **Unit Tests** | **None** | âœ… **Lenient** (no UI thread enforcement) |

### **Real-World Example: Z21 UDP Callback**

```csharp
// Backend.Z21 raises event on UDP thread
_z21.Received += OnFeedbackReceived;

// âŒ WRONG: Direct UI update
private void OnFeedbackReceived(Backend.FeedbackResult result)
{
    stat.Count++;  // âŒ CRASH on Android!
}

// âœ… CORRECT: Dispatched UI update
private void OnFeedbackReceived(Backend.FeedbackResult result)
{
#if ANDROID || IOS || MACCATALYST || WINDOWS
    MainThread.BeginInvokeOnMainThread(() =>
    {
        var stat = Statistics.FirstOrDefault(s => s.InPort == result.InPort);
        if (stat != null)
        {
            stat.Count++;  // âœ… Safe on UI thread
        }
    });
#else
    // Unit test fallback
    var stat = Statistics.FirstOrDefault(s => s.InPort == result.InPort);
    if (stat != null) stat.Count++;
#endif
}
```

### **Debugging Tips:**

1. **Enable Thread Names:**
```csharp
System.Diagnostics.Debug.WriteLine($"Thread: {Thread.CurrentThread.ManagedThreadId}");
```

2. **Check If On Main Thread:**
```csharp
if (!MainThread.IsMainThread)
{
    throw new InvalidOperationException("Must be called on UI thread!");
}
```

3. **Android LogCat Filter:**
```bash
adb logcat | grep -E "Looper|CalledFromWrongThread|RuntimeException"
```

### **Related Guidelines:**
- See **Async/Await Guidelines** (below) for async patterns
- See **MVVM Pattern** for ObservableProperty threading
- See **.NET 10 RC Issues** for other known MAUI problems

# ğŸš€ğŸš€ğŸš€ Advanced Async/Await Usage Guidelines ğŸš€ğŸš€ğŸš€

---

## â“ When to Use Async

- **Use Async for I/O-bound work**: Any operation that involves network, file, or database should be async.
- **Avoid Async for CPU-bound work**: If your method is doing heavy computations, keep it synchronous or offload to a background thread.

## ğŸ“‡ Async Method Naming

- **Suffix with `Async`**: This is crucial for differentiating between sync and async methods at a glance.
- **Example**: For a method that fetches data, use `FetchDataAsync` instead of `FetchData`.

## ğŸš« Anti-Patterns to Avoid

1. **Async Overhead for Simple Tasks**: Don't make simple property getters/setters async. It's unnecessary and adds overhead.
    ```csharp
    // âŒ BAD: Overusing async
    public async Task<int> GetNumberAsync() => await Task.FromResult(_number);
    ```
   
2. **Blocking on Async Code**: Avoid using `.Result` or `.Wait()` on tasks. It can cause deadlocks, especially in UI applications.
    ```csharp
    // âŒ BAD: Blocking async code
    var data = LoadDataAsync().Result; // Potential deadlock!
    ```

3. **Fire-and-Forget**: If you must fire-and-forget, at least log the exceptions in the async method.
    ```csharp
    // âŒ BAD: Ignoring exceptions
    public void Start() { _ = DoWorkAsync(); }
    
    // âœ… GOOD: Handle exceptions
    public void Start()
    {
        _ = Task.Run(async () =>
        {
            try { await DoWorkAsync(); }
            catch (Exception ex) { _logger.LogError(ex, "Error in DoWorkAsync"); }
        });
    }
    ```

4. **Async Void**: This should be avoided except for event handlers. It makes error handling and testing difficult.
    ```csharp
    // âŒ BAD: Async void method
    public async void OnButtonClick()
    {
        await DoSomethingAsync(); // If this fails, it's hard to know!
    }
    ```

## â³ Task.Run() Usage

- **Offload CPU-bound work**: If you have a synchronous method that is CPU-intensive, wrap it in `Task.Run()` to run it on a background thread.
    ```csharp
    public void ProcessData()
    {
        Task.Run(() =>
        {
            // CPU-intensive work here
        });
    }
    ```

## ğŸ”— Configuring Await

- **Use `ConfigureAwait(false)`** in library or backend code where you don't need the context (like UI context).
- **Don't use it in UI code**: Your ViewModels and Views usually need the UI context to update bindings.

    ```csharp
    // âœ… GOOD: Library code
    public async Task<Data> LoadDataAsync()
    {
        var content = await File.ReadAllTextAsync(path).ConfigureAwait(false);
        return Parse(content);
    }
    
    // âŒ BAD: UI code
    public async Task LoadAsync()
    {
        var data = await _service.LoadDataAsync().ConfigureAwait(false); // Don't do this!
        Items = new ObservableCollection<Item>(data); // Needs UI thread
    }
    ```

## ğŸ“‚ IAsyncEnumerable for Streaming Data

- **Use `IAsyncEnumerable<T>` for methods that return a stream of data**: This is especially useful for paging or continuous data feeds.
    ```csharp
    public async IAsyncEnumerable<int> GetNumbersAsync([EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        for (int i = 0; i < 10; i++)
        {
            await Task.Delay(1000, cancellationToken); // Simulate async work
            yield return i;
        }
    }
    ```

## âœ”ï¸ Error Handling in Async

- **Always use try-catch around await**: This is crucial for logging and handling exceptions in async methods.
- **Rethrow exceptions** after logging if you want the caller to handle them.

    ```csharp
    public async Task ConnectAsync()
    {
        try
        {
            await _z21.ConnectAsync();
        }
        catch (SocketException ex)
        {
            _logger.LogError(ex, "Z21 connection failed");
            StatusText = $"Connection failed: {ex.Message}";
            throw; // Important: Rethrow the exception
        }
    }
    ```

## âœ”ï¸ Best Practices Checklist

- [ ] **All I/O operations use async/await?**
- [ ] **No async void methods except for event handlers?**
- [ ] **Methods that don't need the context use ConfigureAwait(false)?**
- [ ] **No deadlocks caused by blocking on async code?**
- [ ] **Fire-and-forget tasks have exception handling?**
- [ ] **Async methods have proper naming (`Async` suffix)?**
- [ ] **IAsyncEnumerable used for streaming data when appropriate?**
