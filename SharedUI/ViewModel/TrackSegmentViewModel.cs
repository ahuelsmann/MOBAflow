// Copyright (c) 2025-2026 Andreas Huelsmann. Licensed under MIT. See LICENSE and README.md for details.
namespace Moba.SharedUI.ViewModel;

using CommunityToolkit.Mvvm.ComponentModel;
using Domain.TrackPlan;

/// <summary>
/// ViewModel for a track segment in the topology-based track plan.
/// Position and PathData are computed by the TrackLayoutRenderer, not stored.
/// </summary>
public partial class TrackSegmentViewModel : ObservableObject
{
    private readonly TrackSegment _segment;

    public TrackSegmentViewModel(TrackSegment segment)
    {
        ArgumentNullException.ThrowIfNull(segment);
        _segment = segment;
    }

    /// <summary>
    /// Access to underlying domain model.
    /// </summary>
    public TrackSegment Model => _segment;




    #region Domain Properties (from TrackSegment)

    public string Id => _segment.Id;
    public string ArticleCode => _segment.ArticleCode;
    public string? Name => _segment.Name;
    public string? Layer => _segment.Layer;

    /// <summary>
    /// Endpoints for rendering and connection matching.
    /// For curves, index [2] contains the arc-point for sweep calculation.
    /// </summary>
    public List<SegmentEndpoint> Endpoints => _segment.Endpoints;

    /// <summary>
    /// Assigned feedback sensor port (InPort 1-2048).
    /// </summary>
    public uint? AssignedInPort
    {
        get => _segment.AssignedInPort;
        set
        {
            if (_segment.AssignedInPort != value)
            {
                _segment.AssignedInPort = value;
                OnPropertyChanged();
                OnPropertyChanged(nameof(HasInPort));
                OnPropertyChanged(nameof(InPortDisplayText));
            }
        }
    }

    public bool HasInPort => _segment.AssignedInPort.HasValue;
    public string InPortDisplayText => _segment.AssignedInPort?.ToString() ?? "";

    #endregion

    #region Render Properties (set by TrackLayoutRenderer)

    /// <summary>
    /// X position (calculated by renderer).
    /// </summary>
    [ObservableProperty]
    private double x;

    /// <summary>
    /// Y position (calculated by renderer).
    /// </summary>
    [ObservableProperty]
    private double y;

    /// <summary>
    /// SVG path data (generated by renderer from Lines/Arcs).
    /// </summary>
    [ObservableProperty]
    private string? pathData = "M 0,0";

    /// <summary>
    /// Rotation in degrees (calculated by renderer for topology-based layout).
    /// WinUI uses RenderTransform to apply rotation.
    /// </summary>
    [ObservableProperty]
    private double rotation;

    #endregion

    #region UI State

    /// <summary>
    /// Whether this segment is currently selected.
    /// </summary>
    [ObservableProperty]
    private bool isSelected;

    /// <summary>
    /// Whether this segment is currently triggered (feedback active).
    /// </summary>
    [ObservableProperty]
    private bool isTriggered;

    /// <summary>
    /// Whether this segment is being dragged.
    /// </summary>
    [ObservableProperty]
    private bool isDragging;

    /// <summary>
    /// Whether this segment is part of a group being dragged.
    /// </summary>
    [ObservableProperty]
    private bool isPartOfDragGroup;

    /// <summary>
    /// Whether this segment is a potential snap target during drag.
    /// </summary>
    [ObservableProperty]
    private bool isSnapTarget;

    #endregion

    #region Drag Support

    /// <summary>
    /// Offset X from segment origin to drag start point.
    /// Used to maintain relative position during drag.
    /// </summary>
    public double DragOffsetX { get; set; }

    /// <summary>
    /// Offset Y from segment origin to drag start point.
    /// </summary>
    public double DragOffsetY { get; set; }

    /// <summary>
    /// Move segment by delta (for group drag).
    /// </summary>
    public void MoveBy(double deltaX, double deltaY)
    {
        X += deltaX;
        Y += deltaY;

        // Also update domain model endpoints
        foreach (var ep in _segment.Endpoints)
        {
            ep.X += deltaX;
            ep.Y += deltaY;
        }

        // Update drawing elements
        foreach (var line in _segment.Lines)
        {
            line.X1 += deltaX;
            line.Y1 += deltaY;
            line.X2 += deltaX;
            line.Y2 += deltaY;
        }

        foreach (var arc in _segment.Arcs)
        {
            arc.X1 += deltaX;
            arc.Y1 += deltaY;
            arc.X2 += deltaX;
            arc.Y2 += deltaY;
        }
    }

    #endregion

    #region Computed Properties for UI

    /// <summary>
    /// Label X position (center of segment).
    /// </summary>
    public double LabelX => X - 10;

    /// <summary>
    /// Label Y position (center of segment).
    /// </summary>
    public double LabelY => Y - 6;

    /// <summary>
    /// InPort label Y position.
    /// </summary>
    public double InPortLabelY => LabelY - 14;

    partial void OnXChanged(double value)
    {
        _ = value;
        OnPropertyChanged(nameof(LabelX));
    }

    partial void OnYChanged(double value)
    {
        _ = value;
        OnPropertyChanged(nameof(LabelY));
        OnPropertyChanged(nameof(InPortLabelY));
    }

    #endregion


}
