---
description: 'Dynamic cross-session knowledge bridge tracking TODOs, decisions, and instruction file status for MOBAflow'
applyTo: '**'
---

# MOBAflow - Cross-Session Knowledge Bridge

> **Cross-Session Knowledge Bridge** fuer Copilot
> **Erstellt:** 2025-02-04 | **Letztes Update:** 2026-01-17

---

## ğŸ—ï¸ Architecture Decision: Auto-Save Pattern (2026-01-17)

> **Entscheidung:** PropertyChanged-basiertes Auto-Save fÃ¼r alle ViewModels
> **Status:** âœ… IMPLEMENTIERT - Konsistent Ã¼ber gesamte Codebase
> **Datum:** 2026-01-17

### Problem
UrsprÃ¼nglich wurde fÃ¼r `WorkflowViewModel` ein neues `DataChanged-Event` Pattern eingefÃ¼hrt, wÃ¤hrend andere ViewModels (`StationViewModel`, `TrainViewModel`) das Standard `PropertyChanged-Event` verwenden.

**Inkonsistenz:**
- âœ… **StationViewModel, TrainViewModel**: PropertyChanged â†’ `OnViewModelPropertyChanged` â†’ Auto-Save
- âŒ **WorkflowViewModel** (alt): DataChanged â†’ `OnWorkflowDataChanged` â†’ Auto-Save

### LÃ¶sung: Konsistentes PropertyChanged-Pattern

**Alle ViewModels verwenden jetzt:**

```csharp
// ViewModel Property Setter (CommunityToolkit.Mvvm Standard)
public string Name
{
    get => _model.Name;
    set => SetProperty(_model.Name, value, _model, (m, v) => m.Name = v);
}

// Nested ViewModels (z.B. WorkflowActionViewModel in WorkflowViewModel)
private void OnActionPropertyChanged(object? sender, PropertyChangedEventArgs e)
{
    // Propagiere als PropertyChanged(nameof(Actions)) fÃ¼r Auto-Save
    OnPropertyChanged(nameof(Actions));
}

// MainWindowViewModel
partial void OnSelectedProjectChanged(ProjectViewModel? value)
{
    if (value != null)
    {
        // Subscribe zu PropertyChanged fÃ¼r alle Workflows
        foreach (var workflow in value.Workflows)
        {
            workflow.PropertyChanged += OnViewModelPropertyChanged;
        }
    }
}

private void OnViewModelPropertyChanged(object? sender, PropertyChangedEventArgs e)
{
    // Ignoriere UI-only Properties
    var ignoredProperties = new[] { "IsSelected", "IsExpanded", "IsHighlighted" };
    if (!ignoredProperties.Contains(e.PropertyName))
    {
        _ = SaveSolutionInternalAsync(); // Auto-Save
    }
}
```

### Benefits

1. âœ… **Konsistenz**: Alle ViewModels verwenden identisches Pattern
2. âœ… **CommunityToolkit.Mvvm Standard**: Nutzt `ObservableObject.PropertyChanged`
3. âœ… **Weniger Code**: Kein separates DataChanged-Event nÃ¶tig
4. âœ… **Einfacher wartbar**: Ein Event-Handler fÃ¼r alle ViewModels
5. âœ… **Nested ViewModels**: Actions propagieren Changes als `PropertyChanged("Actions")`

### Implementierte Ã„nderungen (2026-01-17)

**WorkflowViewModel.cs:**
- âŒ Entfernt: `public event EventHandler? DataChanged;`
- âŒ Entfernt: `DataChanged?.Invoke(this, EventArgs.Empty);`
- âœ… HinzugefÃ¼gt: `OnPropertyChanged(nameof(Actions))` in `UpdateActionNumbers()`, `AddAction()`, `DeleteAction()`
- âœ… HinzugefÃ¼gt: `OnActionPropertyChanged` propagiert als `PropertyChanged("Actions")`

**MainWindowViewModel.Counter.cs:**
- âŒ Entfernt: `workflow.DataChanged += OnWorkflowDataChanged;`
- âœ… HinzugefÃ¼gt: `workflow.PropertyChanged += OnViewModelPropertyChanged;`

**MainWindowViewModel.Workflow.cs:**
- âŒ Entfernt: `OnWorkflowDataChanged` Handler
- âŒ Entfernt: `workflow.DataChanged += OnWorkflowDataChanged;` in `AddWorkflow()`
- âœ… HinzugefÃ¼gt: `workflow.PropertyChanged += OnViewModelPropertyChanged;` in `AddWorkflow()`

### Auto-Save Flow (Konsistent)

```
User Ã¤ndert Workflow-Property (Name, ExecutionMode, etc.)
  â†“
WorkflowViewModel.SetProperty() â†’ OnPropertyChanged("Name")
  â†“
MainWindowViewModel.OnViewModelPropertyChanged() â†’ SaveSolutionInternalAsync()
  â†“
ğŸ’¾ Solution gespeichert

User Ã¤ndert Action-Property (DelayAfterMs, Message, etc.)
  â†“
WorkflowActionViewModel.SetParameter() â†’ OnPropertyChanged("DelayAfterMs")
  â†“
WorkflowViewModel.OnActionPropertyChanged() â†’ OnPropertyChanged("Actions")
  â†“
MainWindowViewModel.OnViewModelPropertyChanged() â†’ SaveSolutionInternalAsync()
  â†“
ğŸ’¾ Solution gespeichert

User zieht Action per Drag & Drop
  â†“
WorkflowViewModel.UpdateActionNumbers() â†’ OnPropertyChanged("Actions")
  â†“
MainWindowViewModel.OnViewModelPropertyChanged() â†’ SaveSolutionInternalAsync()
  â†“
ğŸ’¾ Action-Reihenfolge gespeichert
```

### Lessons Learned

- âœ… Immer prÃ¼fen: Gibt es bereits ein etabliertes Pattern in der Codebase?
- âœ… **Konsistenz > Clever**: PropertyChanged ist gut genug, kein separates Event nÃ¶tig
- âœ… **CommunityToolkit.Mvvm nutzen**: `SetProperty()` triggert automatisch PropertyChanged
- âœ… Nested ViewModels propagieren Changes als `PropertyChanged(nameof(Collection))`

---

## App Shell Architektur (2026-01-15)

> **Ziel:** Zentrales App-Shell-Pattern mit DI-basierter Navigation
> **Status:** âœ… FUNKTIONSFAEHIG - App startet erfolgreich

### App Shell Interfaces (SharedUI/Shell/)

**Neue Interfaces implementiert:**

| Interface | Zweck | Status |
|-----------|-------|--------|
| `INavigationService` | Zentrale Navigation mit History | âœ… Implementiert |
| `IPageFactory` | DI-basierte Page-Erstellung | âœ… Implementiert |
| `ILifecycleHost` | App-weite Lifecycle-Events | âœ… Implementiert |
| `IShellService` | Shell-Regions (Main, Overlay, Sidebar, Footer) | âœ… Implementiert |
| `ShellRegion` (enum) | Regionen-Definition | âœ… Implementiert |
| `PageDescriptor` (record) | Page-Metadaten | âœ… Implementiert |

**WinUI Implementierungen (WinUI/Service/):**

| Service | Beschreibung | Status |
|---------|--------------|--------|
| `NavigationService` | Erweitert um INavigationService, Navigation History | âœ… Erweitert |
| `PageFactory` | DI-basierte Page-Erstellung | âœ… Neu |
| `LifecycleHost` | WinUI Lifecycle-Integration | âœ… Neu |
| `ShellService` | Shell-Region-Management | âœ… Neu |

---

## Responsive Layout - Entscheidung (2026-01-15)

### AdaptivePanel (ENTFERNT)

Das Custom Control `AdaptivePanel` wurde nach ausfuehrlichen Tests **entfernt**, da WinUI 3 zu viele Inkompatibilitaeten mit Custom Controls hat:

| Problem | Ursache |
|---------|---------|
| XAML-Parser Exception | ContentProperty mit ObservableCollection funktioniert nicht |
| DependencyObject nicht erlaubt | Items muessen von FrameworkElement erben |
| Implizite Styles crashen | Custom Controls in ResourceDictionary nicht unterstuetzt |
| GridLength TypeConverter fehlt | Manuelles Parsing erforderlich |

### Empfohlene Alternative: VisualStateManager

Fuer responsive Multi-Column-Layouts wird **VisualStateManager mit AdaptiveTrigger** empfohlen:

```xaml
<Grid>
    <VisualStateManager.VisualStateGroups>
        <VisualStateGroup>
            <VisualState x:Name="WideState">
                <VisualState.StateTriggers>
                    <AdaptiveTrigger MinWindowWidth="1024" />
                </VisualState.StateTriggers>
            </VisualState>
            <VisualState x:Name="CompactState">
                <VisualState.StateTriggers>
                    <AdaptiveTrigger MinWindowWidth="0" />
                </VisualState.StateTriggers>
                <VisualState.Setters>
                    <Setter Target="Panel2.Visibility" Value="Collapsed" />
                </VisualState.Setters>
            </VisualState>
        </VisualStateGroup>
    </VisualStateManager.VisualStateGroups>
</Grid>
```

### Noch verfuegbar: ResponsiveLayoutBehavior

`WinUI/Behavior/ResponsiveLayoutBehavior.cs` ist noch vorhanden und kann fuer VisualStateManager-Integration genutzt werden.

### Naechste Schritte (Optional/Backlog)

- [ ] Unit-Tests fuer GetGridLength() Parser
- [ ] VisualStateManager-basiertes Design fuer TrainControlPage
- [ ] Flyout-basierte Toolbox fuer TrackPlanEditorPage in Compact-Mode

---

## ğŸ¨ NEUE INITIATIVE: WinUI 3 Best Practices Implementation (2026-01-15)

> **Ziel:** Systematische Umsetzung aller WinUI 3 Best Practices mit Fokus auf Responsive Layouts (VisualStateManager)
> **Status:** AKTIV - Step 1-2 abgeschlossen, **Step 3.1 FERTIG**, Step 3.2 nÃ¤chste
> **PrioritÃ¤t:** Stufe 1 (nach Security-Cleanup, vor ReSharper 0-Warnings)

### Hintergrund: Warum VisualStateManager?

WinUI 3 Apps mÃ¼ssen **responsive** sein - nicht hart-kodierte Layouts fÃ¼r feste FenstergrÃ¶ÃŸen. **VisualStateManager (VSM)** mit **AdaptiveTrigger** ist die Microsoft Best Practice fÃ¼r:

- âœ… Automatische Umschaltung zwischen Layouts basierend auf Fensterbreite
- âœ… Tablet/Touch-UnterstÃ¼tzung (Portrait â†” Landscape)
- âœ… Professionelle Smooth Transitions (keine jarring Layout-Shifts)
- âœ… Kein Code-Behind erforderlich (deklarativ, wartbar)
- âœ… Future-proof fÃ¼r beliebig kleine/groÃŸe Fenster

**MOBAflow Breakpoints definiert:**
- **Compact:** 0-640px (Mobile/kleine Fenster)
- **Medium:** 641-1199px (Tablet/Tablet Landscape)
- **Wide:** 1200px+ (Desktop/groÃŸer Monitor)

**Siehe auch:** Umfassende Dokumentation in `.github/instructions/winui.instructions.md` (neue Sektion "Responsive Layout with VisualStateManager")

### Step 1: VSM-Dokumentation (âœ… FERTIG - 2026-01-15)

**Umgesetzt:**
- âœ… Erweiterte `winui.instructions.md` mit umfassender VSM-ErklÃ¤rung (Conceptual Guide + Code Examples)
- âœ… MOBAflow-spezifische Breakpoints dokumentiert
- âœ… Komplettes TrainControlPage-Beispiel mit 3 States (Wide/Medium/Compact)
- âœ… HÃ¤ufige VSM-Patterns (Hide/Show, Column Width, Stacking)
- âœ… Window-Resize Testing Guide
- âœ… Architecture Decision Log (warum VSM, nicht Custom Controls)

**Ergebnis:** Entwickler verstehen jetzt VSM-Konzept vollstÃ¤ndig und kÃ¶nnen es sofort anwenden.

### Step 2: XAML-Audit aller Haupt-Pages (âœ… FERTIG - 2026-01-15)

**Audit-Ergebnisse:**

| Page | Layout | Status | Breakpoints | PrioritÃ¤t |
|------|--------|--------|------------|-----------|
| **TrainControlPage.xaml** | Grid (3 Spalten, hart-kodiert) | âœ… **VSM IMPLEMENTIERT (2026-01-17)** | Wide: 3 Spalten \| Medium: 2 Spalten \| Compact: Stack | ğŸ”´ âœ… FERTIG |
| **TrackPlanEditorPage.xaml** | Grid (3 Spalten: Toolbox \| Canvas \| Palette) | â³ **NÃ„CHSTE** | Wide: 3 Spalten \| Medium: Canvas Full + Toolbox unten \| Compact: Toolbox Modal | ğŸ”´ HOCH |
| **SignalBoxPage.cs** | Programmatisch (Code-Behind XAML) | âš ï¸ Braucht XAML + VSM | Wide: Grid \| Medium: Compact | ğŸŸ  MITTEL |
| **MainWindow.xaml** | NavigationView (Shell) | â³ Noch zu prÃ¼fen | Wide: Rail sichtbar \| Compact: Hamburger | ğŸŸ  MITTEL |
| **WorkflowsPage.xaml** | ListBox + Editor | â³ Noch zu prÃ¼fen | Wide: Split \| Compact: Modal | ğŸŸ  MITTEL |
| **MonitorPage.xaml** | Horizontal Logs | âœ… Wahrscheinlich OK | - | ğŸŸ¢ NIEDRIG |

**Erkenntnisse:**
- âŒ ~~Keine Page hat aktuell VSM implementiert~~ â†’ TrainControlPage âœ… VSM implementiert
- âœ… TrainControlPage als Vorbild-Implementierung
- âœ… Gute Grundstruktur (Grid-basiert, proper spacing, CardBackground, Fluent Design)
- âš ï¸ SignalBoxPage ist vollstÃ¤ndig Code-Behind generiert (sollte zu XAML migriert werden fÃ¼r Wartbarkeit)

### Step 3: VSM-Implementierung in Haupt-Pages

#### Step 3.1: TrainControlPage.xaml (âœ… FERTIG - 2026-01-17)

**Implementiert:**
- âœ… VSM mit Wide/Medium/Compact States
- âœ… Breakpoints: Wide (1200px+) | Medium (641-1199px) | Compact (0-640px)
- âœ… Wide: [Settings (260px) | Tachometer (*) | Functions (180px)]
- âœ… Medium: [Settings (250px) | Tachometer (*)] - Functions verborgen
- âœ… Compact: Single column, alle Panels gestackt
- âœ… All 21 function buttons (F0-F20) working with Command binding
- âœ… BacklightConverter for button colors
- âœ… Tested with resize from 1920px â†’ 1200px â†’ 640px â†’ 320px
- âœ… Build erfolgreich

**Testing Status:**
- âœ… UI Buttons responsive und klickbar (auch ohne Z21 connection zum Testen)
- âœ… Function button colors zeigen sich korrekt (Background binding)
- âœ… CanExecuteLocoCommand temporarily disabled (`=> true`) fÃ¼r Testing
- âœ… TODO: SpÃ¤ter wieder `_z21.IsConnected` check aktivieren

**UX-Fix (2026-01-17 Session):**
- ğŸš¨ **ISSUE GEFUNDEN:** VSM-Refactoring (2a22af7) ersetzte BacklightToggleButtonStyle mit inline Properties, verlor VisualStates (Hover, Press, Disabled)
- âœ… **GELÃ–ST:** Alle F0-F20 Buttons zurÃ¼ck zu BacklightToggleButtonStyle
- âœ… Inline Properties (Height, CornerRadius, FontSize, FontWeight) entfernt
- âœ… Grid layout und Background binding bleiben erhalten
- âœ… Alle VisualStates (PointerOver, Pressed, CheckedPointerOver, CheckedPressed, Disabled) wiederhergestellt
- âœ… Build erfolgreich validiert

#### Step 3.2: TrackPlanEditorPage.xaml (ğŸ”´ **AKTUELLE AUFGABE**)

**Aufgabe:** 3-Spalten Layout (Toolbox | Canvas | Properties) â†’ VSM
- Breakpoints:
  - **Wide:** [Toolbox (180px) | Canvas (*) | Properties (240px)]
  - **Medium:** [Canvas full-width] mit Properties darunter oder als Flyout
  - **Compact:** Canvas full-screen, Toolbox/Properties als Modal/Flyout
- Tests: Touch-Simulation, Rotation (Landscape â†” Portrait)
- GeschÃ¤tzter Aufwand: 1-2 Stunden
- Nutzen: Track Planning auf Tablet, bessere Touchscreen-UnterstÃ¼tzung

---

## ğŸ¨ VSM + UX Preservation Strategy (NEU - 2026-01-17)

> **Problem:** VisualStateManager soll responsive Layout bieten OHNE UI/UX-Polishing zu verlieren
> **Status:** âš ï¸ **KRITISCHER FUND** - TrainControlPage verlor BacklightToggleButtonStyle!
> **Datum:** 2026-01-17

### ğŸš¨ WARNUNG: TrainControlPage.xaml - Was VERLOREN ging (REAL ISSUE)

**VOR VSM-Implementation (d4025e0 - BacklightToggleButtonStyle):**
```xaml
<!-- âœ… GUTE UX: Style mit allen VisualStates -->
<ToggleButton
    Style="{StaticResource BacklightToggleButtonStyle}"
    Background="{x:Bind ViewModel.IsF0On, Converter={BacklightConverter}, ConverterParameter=#FFD700}"
    Command="{x:Bind ViewModel.ToggleF0Command}"
    Content="F0"
    IsChecked="{x:Bind ViewModel.IsF0On}" />
```

**NACH VSM-Implementation (2a22af7 - Inline Properties):**
```xaml
<!-- âŒ SCHLECHTE UX: Inline Properties, kein Style, verliert VisualStates -->
<ToggleButton
    Grid.Row="0"
    Grid.Column="0"
    Height="40"
    HorizontalAlignment="Stretch"
    Background="{x:Bind ViewModel.IsF0On, Mode=OneWay, Converter={StaticResource BacklightConverter}, ConverterParameter=#FFD700}"
    Command="{x:Bind ViewModel.ToggleF0Command}"
    Content="F0"
    CornerRadius="6"
    FontSize="12"
    FontWeight="SemiBold"
    IsChecked="{x:Bind ViewModel.IsF0On, Mode=OneWay}" />
```

### Was wurde verloren?

**BacklightToggleButtonStyle VisualStates (noch vorhanden in ControlStyles.xaml):**
- âŒ **PointerOver State**: Border und Highlight bei Hover weg
- âŒ **Pressed State**: Press-Feedback bei Click weg  
- âŒ **CheckedPointerOver State**: Fokus/Highlight auf aktivem Button weg
- âŒ **CheckedPressed State**: Press-Feedback auf aktivem Button weg
- âŒ **Disabled State**: Visuelles Disabled-Feedback weg
- âœ… **Normal State**: Basis-Design bleibt

### Warum passierte das?

Die Refactoring fÃ¼r VSM hatte folgende Probleme:
1. âŒ Buttons wurden aus dem Style herausgenommen
2. âŒ Inline Properties wurden hinzugefÃ¼gt (Height, CornerRadius, etc.)
3. âŒ Style-Reference wurde entfernt  
4. âœ… Background Binding blieb erhalten
5. âœ… Farben bleiben visuell, aber interaktive States verschwinden

### Die Lehre fÃ¼r die anderen Pages

**KRITISCHES RULE fÃ¼r VSM-Implementation:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ NIEMALS Custom Styles durch inline Properties ersetzen!     â”‚
â”‚                                                              â”‚
â”‚ âœ… RICHTIG:                                                 â”‚
â”‚ <ToggleButton Style="{StaticResource CustomStyle}"          â”‚
â”‚              Background="..." />   â† Style + Binding        â”‚
â”‚                                                              â”‚
â”‚ âŒ FALSCH:                                                  â”‚
â”‚ <ToggleButton Height="40" CornerRadius="6"                 â”‚
â”‚              Background="..." />   â† Keine VisualStates     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸš¨ VSM-MIGRATION SAFETY GUIDELINES (2026-01-17)

> **KRITISCH:** Folgende Regeln MÃœSSEN eingehalten werden, um UI/UX nicht zu verlieren!
> **Kontext:** Commit 2a22af7 (-576, +409 Zeilen) war groÃŸes Refactoring mit collateral damage
> **Status:** ğŸ“‹ DOKUMENTIERT - FÃ¼r alle zukÃ¼nftigen Pages verbindlich

### Root Cause Analysis: Was passierte bei TrainControlPage?

**Commit 2a22af7 (14.01.2026) - "feat(winui): VisualStateManager responsive layout & docs"**
- ğŸ“Š -576 Zeilen entfernt, +409 Zeilen hinzugefÃ¼gt = groÃŸes Refactoring
- âŒ **Problem:** GroÃŸe Refactorings sind fehleranfÃ¤llig
- âŒ **Issue:** VSM-Implementation ersetzte Style-Referenzen durch inline Properties
- âœ… **Folge:** BacklightToggleButtonStyle verloren, aber ControlStyles.xaml nicht gelÃ¶scht
- ğŸ”§ **Fix:** 2026-01-17 Session restaurierte alle 21 Function Buttons mit Style-Referenzen

**Timeline:**
```
d4025e0 (Initial): BacklightToggleButtonStyle âœ… funktioniert
    â†“
2a22af7 (VSM Refactor): Inline Properties ersetzen Style âŒ VisualStates weg
    â†“
Heute (2026-01-17): Restauriere Styles, entferne inline Properties âœ… Alles wieder gut
```

### Kernproblem: "Flaches" VSM Design

**Symptome:**
- Layout passt sich an Fensterbreite an âœ…
- Aber Buttons/Controls sehen "trocken" aus âŒ
- Hover-States, Press-Feedback, Farb-ÃœbergÃ¤nge verschwinden âŒ
- Resultat: UX fÃ¼hlt sich "Beta" oder "unfertig" an âŒ

**Root Cause:** Versehentliche Entfernung von Custom Styles wÃ¤hrend VSM-Refactoring

### ğŸ¯ Goldene Regel fÃ¼r VSM-Migration

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  VSM = LAYOUT NUR (Separation!)                  â”‚
â”‚                                                                  â”‚
â”‚  âœ… VSM Setters dÃ¼rfen Ã¤ndern:                                  â”‚
â”‚     â€¢ Control.Visibility (Show/Hide Panels)                     â”‚
â”‚     â€¢ Grid.ColumnDefinitions Width (Spalten-GrÃ¶ÃŸe)             â”‚
â”‚     â€¢ Margin/Padding (kleine Spacing-Anpassungen)              â”‚
â”‚                                                                  â”‚
â”‚  âŒ VSM Setters dÃ¼rfen NICHT Ã¤ndern:                            â”‚
â”‚     â€¢ Style (NIEMALS!)                                          â”‚
â”‚     â€¢ Height/Width inline (gehÃ¶rt in Style!)                   â”‚
â”‚     â€¢ CornerRadius inline (gehÃ¶rt in Style!)                   â”‚
â”‚     â€¢ FontSize/FontWeight inline (gehÃ¶rt in Style!)            â”‚
â”‚     â€¢ Background Binding (gehÃ¶rt in XAML Control!)             â”‚
â”‚     â€¢ Converter (gehÃ¶rt in Page.Resources!)                    â”‚
â”‚                                                                  â”‚
â”‚  â†’ UI/UX Polishing bleibt in Controls/Styles/Converter         â”‚
â”‚  â†’ VSM macht nur Responsive-Layout                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ“‹ PRE-MIGRATION CHECKLIST (vor TrackPlanEditorPage / weiteren Pages)

**MUSS vor VSM-Refactoring durchgefÃ¼hrt werden:**

- [ ] **Code-Audit:** Welche Custom Styles werden verwendet?
  - [ ] Alle Styles identifizieren (z.B. `BacklightToggleButtonStyle`, `DangerButtonStyle`)
  - [ ] Wo werden sie verwendet? (z.B. "F0-F20 ToggleButtons in TrainControlPage")
  - [ ] Sind sie noch in ControlStyles.xaml vorhanden?

- [ ] **Converter-Audit:** Welche Data Converters gibt es?
  - [ ] Alle Converter dokumentieren (z.B. `BacklightConverter`, `IntToPresetCheckedConverter`)
  - [ ] Wo sind sie registriert? (Page.Resources oder App.xaml)
  - [ ] Welche Controls nutzen sie? (Background Binding, IsChecked Binding, etc.)

- [ ] **VisualStates-Audit:** Welche VisualStates existieren in Custom Styles?
  - [ ] Alle VisualStates dokumentieren (PointerOver, Pressed, Checked, Disabled, etc.)
  - [ ] Notieren welche States WICHTIG fÃ¼r UX sind

- [ ] **Layout-Planung fÃ¼r 3 Breakpoints:**
  - [ ] **Wide (1200px+):** Skizze zeichnen - wie sollen alle Panels sichtbar sein?
  - [ ] **Medium (641-1199px):** Welche Panels verstecken? Welche wachsen?
  - [ ] **Compact (0-640px):** Modal/Flyout fÃ¼r versteckte Panels planen?
  - [ ] Notieren: Grid.ColumnDefinitions fÃ¼r jeden State

- [ ] **Test-Plan erstellen:**
  - [ ] Welche Resize-Breakpoints testen? (1920 â†’ 1200 â†’ 800 â†’ 640 â†’ 320)
  - [ ] Hover/Press/Disabled States auf jeder GrÃ¶ÃŸe testen?
  - [ ] Touch-Test erforderlich?
  - [ ] Keyboard-Navigation noch funktional?

### ğŸ“‹ DURING-MIGRATION CHECKLIST (wÃ¤hrend VSM-Refactoring)

**MUSS wÃ¤hrend des Refactorings eingehalten werden:**

- [ ] **NIEMALS Styles entfernen/ersetzen**
  - [ ] Jeder ToggleButton: `Style="{StaticResource BacklightToggleButtonStyle}"`
  - [ ] Jeder Button: Behalte `Style="{StaticResource ...}"` bei
  - [ ] PrÃ¼fe: Werden Styles durch inline Properties ersetzt? â†’ STOPP!

- [ ] **NIEMALS Bindings/Converter entfernen**
  - [ ] Background-Bindings bleiben: `Background="{x:Bind IsOn, Converter={...}}"`
  - [ ] IsChecked-Bindings bleiben: `IsChecked="{x:Bind IsChecked}"`
  - [ ] Alle Converter-Parameter bleiben: `ConverterParameter=#FFD700`

- [ ] **Grid Layout Properties bewahren**
  - [ ] `Grid.Row` / `Grid.Column` nicht anfassen
  - [ ] `Grid.RowSpan` / `Grid.ColumnSpan` nicht anfassen
  - [ ] Nur `Grid.ColumnDefinitions` im VSM Setter Ã¤ndern!

- [ ] **VSM Setters minimal halten**
  - [ ] Nur Visibility Ã¤ndern: `<Setter Target="Panel.Visibility" Value="Collapsed" />`
  - [ ] Nur ColumnDefinitions: `<Setter Target="MainGrid.ColumnDefinitions" Value="*,*,*" />`
  - [ ] Nur kleine Spacing-Fixes wenn nÃ¶tig: `<Setter Target="Panel.Margin" Value="0,16,0,0" />`

- [ ] **BUILD IM ZWEITEN SCHRITT!**
  - [ ] Erst alle XAML-Ã„nderungen abgeschlossen
  - [ ] Dann `dotnet build` ausfÃ¼hren
  - [ ] Nur wenn Build erfolgreich: Weitermachen

### ğŸ“‹ POST-MIGRATION CHECKLIST (nach VSM-Implementation)

**MUSS nach dem Refactoring geprÃ¼ft werden:**

- [ ] **Build erfolgreich?**
  - [ ] `dotnet build` ohne Fehler
  - [ ] Keine XAML Parser Exceptions
  - [ ] Keine CS0103 "InitializeComponent does not exist" Fehler

- [ ] **Visual Regression Test auf allen 3 Breakpoints:**
  - [ ] **Wide (1920px):** Alle Panels sichtbar und gut angeordnet?
  - [ ] **Medium (800px):** Layout umgeschaltet, alle Controls sichtbar?
  - [ ] **Compact (320px):** Single-Column, readable auf kleinem Screen?

- [ ] **UI/UX Polishing noch vorhanden?**
  - [ ] âœ… Farben noch sichtbar? (BacklightConverter funktioniert)
  - [ ] âœ… Hover-States noch funktional? (PointerOver Effekt beim Hover)
  - [ ] âœ… Press-Feedback noch da? (Button wird dunkler beim DrÃ¼cken)
  - [ ] âœ… Disabled-State funktioniert? (grau, keine Interaktion)
  - [ ] âœ… Icons/Symbole noch sichtbar?

- [ ] **InteraktivitÃ¤t noch funktional?**
  - [ ] Alle Buttons klickbar?
  - [ ] Alle Slider/Inputs funktionieren?
  - [ ] Command Bindings noch aktiv?
  - [ ] Keyboard Navigation noch mÃ¶glich?

- [ ] **Kein visuelles Artefakten?**
  - [ ] Keine Cut-off Controls
  - [ ] Keine Clipping/Overflow
  - [ ] Keine jarring Layout-Shifts beim Resize
  - [ ] Smooth Transitions?

---

## ğŸ¯ VSM-MIGRATION BEST PRACTICES

### Best Practice #1: Style + Binding Pattern

**âœ… RICHTIG: Style-Reference + Background-Binding separate**

```xaml
<ToggleButton
    Grid.Row="0"
    Grid.Column="0"
    Style="{StaticResource BacklightToggleButtonStyle}"
    Background="{x:Bind ViewModel.IsF0On, Mode=OneWay, 
                 Converter={StaticResource BacklightConverter}, 
                 ConverterParameter=#FFD700}"
    Command="{x:Bind ViewModel.ToggleF0Command}"
    Content="F0"
    IsChecked="{x:Bind ViewModel.IsF0On, Mode=OneWay}" />
```

**âŒ FALSCH: Inline Properties statt Style**

```xaml
<!-- WÃ¼rde VisualStates verlieren! -->
<ToggleButton
    Grid.Row="0"
    Grid.Column="0"
    Height="40"
    CornerRadius="6"
    FontSize="12"
    FontWeight="SemiBold"
    Background="{x:Bind ViewModel.IsF0On, Mode=OneWay, 
                 Converter={StaticResource BacklightConverter}, 
                 ConverterParameter=#FFD700}"
    Command="{x:Bind ViewModel.ToggleF0Command}"
    Content="F0"
    IsChecked="{x:Bind ViewModel.IsF0On, Mode=OneWay}" />
```

### Best Practice #2: VSM Setters = Layout Only

**âœ… RICHTIG: Nur Visibility und Grid-Spalten Ã¤ndern**

```xaml
<VisualState x:Name="WideState">
    <VisualState.StateTriggers>
        <AdaptiveTrigger MinWindowWidth="1200" />
    </VisualState.StateTriggers>
    <VisualState.Setters>
        <!-- Panelsichtbarkeit -->
        <Setter Target="ToolboxPanel.Visibility" Value="Visible" />
        <Setter Target="PropertiesPanel.Visibility" Value="Visible" />
        
        <!-- Grid-Spalten -->
        <Setter Target="MainGrid.ColumnDefinitions" Value="180,*,240" />
    </VisualState.Setters>
</VisualState>
```

**âŒ FALSCH: UI-Styling in VSM Ã¤ndern**

```xaml
<!-- WÃ¼rde Style Ã¼berschreiben! -->
<VisualState x:Name="WideState">
    <VisualState.Setters>
        <Setter Target="Button.Height" Value="40" />
        <Setter Target="Button.Background" Value="Blue" />
        <Setter Target="Button.FontSize" Value="14" />
        <!-- â† Das gehÃ¶rt NICHT in VSM! -->
    </VisualState.Setters>
</VisualState>
```

### Best Practice #3: Breakpoint-Dokumentation

**FÃ¼r jede Page DOKUMENTIEREN:**

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  PAGE: TrackPlanEditorPage.xaml - Responsive Breakpoints
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ Wide (1200px+) - Desktop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [Toolbox 180px] | [Canvas *] | [Properties 240px]         â”‚
â”‚  âœ“ Alle 3 Panels nebeneinander                             â”‚
â”‚  âœ“ Maximale ProduktivitÃ¤t fÃ¼r Power User                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€ Medium (641-1199px) - Tablet Landscape â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [Canvas full-width]                                        â”‚
â”‚  [Toolbox Tab] [Properties Tab]  â† Bottom Tabs             â”‚
â”‚  âœ“ Canvas grÃ¶ÃŸer fÃ¼r bessere Ansicht                       â”‚
â”‚  âœ“ Toolbox/Properties auf Demand zeigbar                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€ Compact (0-640px) - Mobile â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [Canvas full-screen]                                       â”‚
â”‚  Toolbox: FAB + Modal Flyout                                â”‚
â”‚  Properties: FAB + Modal Flyout                             â”‚
â”‚  âœ“ Fokus auf Canvas                                         â”‚
â”‚  âœ“ Tools nur wenn aktiv benÃ¶tigt                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Grid Definition:
  Wide:    ColumnDefinitions = "180,*,240"
  Medium:  ColumnDefinitions = "*" (Canvas nur, Tabs unten)
  Compact: ColumnDefinitions = "*" (Canvas nur, Modal FABs)
```

---

## â³ NÃ„CHSTE AUFGABEN (VSM-Migration fÃ¼r andere Pages)

### Step 3.2: TrackPlanEditorPage.xaml (ğŸ”´ NÃ„CHSTE AUFGABE)

**Breakpoints:**
- Wide: [Toolbox 180px | Canvas * | Properties 240px]
- Medium: Canvas full-width, Properties darunter oder Tabs
- Compact: Canvas full-screen, Toolbox/Properties als Modal/FAB

**Aufwand:** 1-2h | **PrioritÃ¤t:** ğŸ”´ HOCH  
**Safety Guidelines:** âœ… Pre-Migration Checklist durchfÃ¼hren

### Step 3.3: SignalBoxPage.xaml (ğŸŸ  MITTEL)

**Hindernis:** Komplett Code-Behind generierte XAML  
**Plan:** Zur XAML umschreiben, dann VSM hinzufÃ¼gen  
**Aufwand:** 2-3h | **PrioritÃ¤t:** ğŸŸ  MITTEL

### Step 3.4: MainWindow.xaml Navigation Shell (ğŸŸ  MITTEL)

**Breakpoints:**
- Wide: NavigationView Rail (links)
- Compact: Hamburger Menu
**Aufwand:** 1-2h | **PrioritÃ¤t:** ğŸŸ  MITTEL

### Step 3.5: WorkflowsPage.xaml (ğŸŸ  MITTEL)

**Breakpoints:**
- Wide: List + Editor nebeneinander
- Compact: Workflow List nur, Editor als Modal
**Aufwand:** 1-2h | **PrioritÃ¤t:** ğŸŸ  MITTEL

---

## ğŸ¨ OPTIONAL UI ENHANCEMENTS

### ğŸŸ¢ Icons/Symbole in Function-Buttons (Optional)

> **Observation:** User merkte an "mir ist aufgefallen, dass die schÃ¶nen symbole noch fehlen in den funktionstasten"

**Idee:** Jeder F0-F20 Button mit kleinem Icon + Text

**Beispiel Icons (WinUI Segoe MDL2):**
```
F0  = ğŸ’¡ Light          (Glyph="&#xE7B7;")
F1  = ğŸ”Š Sound          (Glyph="&#xE7F1;")  
F2  = ğŸ“¯ Horn           (Glyph="&#xE7C0;")
F3  = ğŸšª Door Close     (Glyph="&#xE787;")
F4  = ğŸ”“ Door Open      (Glyph="&#xE8AC;")
F5  = âš¡ Shunt Light    (Glyph="&#xE7E8;")
F6  = ğŸ® Interior Light (Glyph="&#xEB9D;")
F7  = ğŸ’¨ Smoke          (Glyph="&#xE7E9;")
F8  = â¬†ï¸ Pantograph     (Glyph="&#xE7E7;")
F9  = ğŸ”— Coupler        (Glyph="&#xEA3B;")
```

**XAML Pattern:**
```xaml
<ToggleButton
    Style="{StaticResource BacklightToggleButtonStyle}"
    Background="{x:Bind ViewModel.IsF0On, Converter={BacklightConverter}, ConverterParameter=#FFD700}"
    Command="{x:Bind ViewModel.ToggleF0Command}"
    IsChecked="{x:Bind ViewModel.IsF0On, Mode=OneWay}">
    <StackPanel Orientation="Vertical" Spacing="4">
        <FontIcon FontSize="18" Glyph="&#xE7B7;" /> <!-- Lightbulb -->
        <TextBlock FontSize="10" Text="F0" HorizontalTextAlignment="Center" />
    </StackPanel>
</ToggleButton>
```

**Status:** â³ OPTIONAL (nice-to-have, nicht blocking)  
**Aufwand:** 1h fÃ¼r alle 21 Buttons | **Benefit:** Visual Appeal â­â­
