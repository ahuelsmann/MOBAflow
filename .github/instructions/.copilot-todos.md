---
description: 'Dynamic cross-session knowledge bridge tracking TODOs, decisions, and instruction file status for MOBAflow'
applyTo: '**'
---

# MOBAflow - Cross-Session Knowledge Bridge

> **Cross-Session Knowledge Bridge** fuer Copilot
> **Erstellt:** 2025-02-04 | **Letztes Update:** 2026-01-17

---

## ðŸ—ï¸ Architecture Decision: Auto-Save Pattern (2026-01-17)

> **Entscheidung:** PropertyChanged-basiertes Auto-Save fÃ¼r alle ViewModels
> **Status:** âœ… IMPLEMENTIERT - Konsistent Ã¼ber gesamte Codebase
> **Datum:** 2026-01-17

### Problem
UrsprÃ¼nglich wurde fÃ¼r `WorkflowViewModel` ein neues `DataChanged-Event` Pattern eingefÃ¼hrt, wÃ¤hrend andere ViewModels (`StationViewModel`, `TrainViewModel`) das Standard `PropertyChanged-Event` verwenden.

**Inkonsistenz:**
- âœ… **StationViewModel, TrainViewModel**: PropertyChanged â†’ `OnViewModelPropertyChanged` â†’ Auto-Save
- âŒ **WorkflowViewModel** (alt): DataChanged â†’ `OnWorkflowDataChanged` â†’ Auto-Save

### LÃ¶sung: Konsistentes PropertyChanged-Pattern

**Alle ViewModels verwenden jetzt:**

```csharp
// ViewModel Property Setter (CommunityToolkit.Mvvm Standard)
public string Name
{
    get => _model.Name;
    set => SetProperty(_model.Name, value, _model, (m, v) => m.Name = v);
}

// Nested ViewModels (z.B. WorkflowActionViewModel in WorkflowViewModel)
private void OnActionPropertyChanged(object? sender, PropertyChangedEventArgs e)
{
    // Propagiere als PropertyChanged(nameof(Actions)) fÃ¼r Auto-Save
    OnPropertyChanged(nameof(Actions));
}

// MainWindowViewModel
partial void OnSelectedProjectChanged(ProjectViewModel? value)
{
    if (value != null)
    {
        // Subscribe zu PropertyChanged fÃ¼r alle Workflows
        foreach (var workflow in value.Workflows)
        {
            workflow.PropertyChanged += OnViewModelPropertyChanged;
        }
    }
}

private void OnViewModelPropertyChanged(object? sender, PropertyChangedEventArgs e)
{
    // Ignoriere UI-only Properties
    var ignoredProperties = new[] { "IsSelected", "IsExpanded", "IsHighlighted" };
    if (!ignoredProperties.Contains(e.PropertyName))
    {
        _ = SaveSolutionInternalAsync(); // Auto-Save
    }
}
```

### Benefits

1. âœ… **Konsistenz**: Alle ViewModels verwenden identisches Pattern
2. âœ… **CommunityToolkit.Mvvm Standard**: Nutzt `ObservableObject.PropertyChanged`
3. âœ… **Weniger Code**: Kein separates DataChanged-Event nÃ¶tig
4. âœ… **Einfacher wartbar**: Ein Event-Handler fÃ¼r alle ViewModels
5. âœ… **Nested ViewModels**: Actions propagieren Changes als `PropertyChanged("Actions")`

### Implementierte Ã„nderungen (2026-01-17)

**WorkflowViewModel.cs:**
- âŒ Entfernt: `public event EventHandler? DataChanged;`
- âŒ Entfernt: `DataChanged?.Invoke(this, EventArgs.Empty);`
- âœ… HinzugefÃ¼gt: `OnPropertyChanged(nameof(Actions))` in `UpdateActionNumbers()`, `AddAction()`, `DeleteAction()`
- âœ… HinzugefÃ¼gt: `OnActionPropertyChanged` propagiert als `PropertyChanged("Actions")`

**MainWindowViewModel.Counter.cs:**
- âŒ Entfernt: `workflow.DataChanged += OnWorkflowDataChanged;`
- âœ… HinzugefÃ¼gt: `workflow.PropertyChanged += OnViewModelPropertyChanged;`

**MainWindowViewModel.Workflow.cs:**
- âŒ Entfernt: `OnWorkflowDataChanged` Handler
- âŒ Entfernt: `workflow.DataChanged += OnWorkflowDataChanged;` in `AddWorkflow()`
- âœ… HinzugefÃ¼gt: `workflow.PropertyChanged += OnViewModelPropertyChanged;` in `AddWorkflow()`

### Auto-Save Flow (Konsistent)

```
User Ã¤ndert Workflow-Property (Name, ExecutionMode, etc.)
  â†“
WorkflowViewModel.SetProperty() â†’ OnPropertyChanged("Name")
  â†“
MainWindowViewModel.OnViewModelPropertyChanged() â†’ SaveSolutionInternalAsync()
  â†“
ðŸ’¾ Solution gespeichert

User Ã¤ndert Action-Property (DelayAfterMs, Message, etc.)
  â†“
WorkflowActionViewModel.SetParameter() â†’ OnPropertyChanged("DelayAfterMs")
  â†“
WorkflowViewModel.OnActionPropertyChanged() â†’ OnPropertyChanged("Actions")
  â†“
MainWindowViewModel.OnViewModelPropertyChanged() â†’ SaveSolutionInternalAsync()
  â†“
ðŸ’¾ Solution gespeichert

User zieht Action per Drag & Drop
  â†“
WorkflowViewModel.UpdateActionNumbers() â†’ OnPropertyChanged("Actions")
  â†“
MainWindowViewModel.OnViewModelPropertyChanged() â†’ SaveSolutionInternalAsync()
  â†“
ðŸ’¾ Action-Reihenfolge gespeichert
```

### Lessons Learned

- âœ… Immer prÃ¼fen: Gibt es bereits ein etabliertes Pattern in der Codebase?
- âœ… **Konsistenz > Clever**: PropertyChanged ist gut genug, kein separates Event nÃ¶tig
- âœ… **CommunityToolkit.Mvvm nutzen**: `SetProperty()` triggert automatisch PropertyChanged
- âœ… Nested ViewModels propagieren Changes als `PropertyChanged(nameof(Collection))`

---

## App Shell Architektur (2026-01-15)

> **Ziel:** Zentrales App-Shell-Pattern mit DI-basierter Navigation
> **Status:** âœ… FUNKTIONSFAEHIG - App startet erfolgreich

### App Shell Interfaces (SharedUI/Shell/)

**Neue Interfaces implementiert:**

| Interface | Zweck | Status |
|-----------|-------|--------|
| `INavigationService` | Zentrale Navigation mit History | âœ… Implementiert |
| `IPageFactory` | DI-basierte Page-Erstellung | âœ… Implementiert |
| `ILifecycleHost` | App-weite Lifecycle-Events | âœ… Implementiert |
| `IShellService` | Shell-Regions (Main, Overlay, Sidebar, Footer) | âœ… Implementiert |
| `ShellRegion` (enum) | Regionen-Definition | âœ… Implementiert |
| `PageDescriptor` (record) | Page-Metadaten | âœ… Implementiert |

**WinUI Implementierungen (WinUI/Service/):**

| Service | Beschreibung | Status |
|---------|--------------|--------|
| `NavigationService` | Erweitert um INavigationService, Navigation History | âœ… Erweitert |
| `PageFactory` | DI-basierte Page-Erstellung | âœ… Neu |
| `LifecycleHost` | WinUI Lifecycle-Integration | âœ… Neu |
| `ShellService` | Shell-Region-Management | âœ… Neu |

---

## Responsive Layout - Entscheidung (2026-01-15)

### AdaptivePanel (ENTFERNT)

Das Custom Control `AdaptivePanel` wurde nach ausfuehrlichen Tests **entfernt**, da WinUI 3 zu viele Inkompatibilitaeten mit Custom Controls hat:

| Problem | Ursache |
|---------|---------|
| XAML-Parser Exception | ContentProperty mit ObservableCollection funktioniert nicht |
| DependencyObject nicht erlaubt | Items muessen von FrameworkElement erben |
| Implizite Styles crashen | Custom Controls in ResourceDictionary nicht unterstuetzt |
| GridLength TypeConverter fehlt | Manuelles Parsing erforderlich |

### Empfohlene Alternative: VisualStateManager

Fuer responsive Multi-Column-Layouts wird **VisualStateManager mit AdaptiveTrigger** empfohlen:

```xaml
<Grid>
    <VisualStateManager.VisualStateGroups>
        <VisualStateGroup>
            <VisualState x:Name="WideState">
                <VisualState.StateTriggers>
                    <AdaptiveTrigger MinWindowWidth="1024" />
                </VisualState.StateTriggers>
            </VisualState>
            <VisualState x:Name="CompactState">
                <VisualState.StateTriggers>
                    <AdaptiveTrigger MinWindowWidth="0" />
                </VisualState.StateTriggers>
                <VisualState.Setters>
                    <Setter Target="Panel2.Visibility" Value="Collapsed" />
                </VisualState.Setters>
            </VisualState>
        </VisualStateGroup>
    </VisualStateManager.VisualStateGroups>
</Grid>
```

### Noch verfuegbar: ResponsiveLayoutBehavior

`WinUI/Behavior/ResponsiveLayoutBehavior.cs` ist noch vorhanden und kann fuer VisualStateManager-Integration genutzt werden.

### Naechste Schritte (Optional/Backlog)

- [ ] Unit-Tests fuer GetGridLength() Parser
- [ ] VisualStateManager-basiertes Design fuer TrainControlPage
- [ ] Flyout-basierte Toolbox fuer TrackPlanEditorPage in Compact-Mode

---

## ðŸŽ¨ NEUE INITIATIVE: WinUI 3 Best Practices Implementation (2026-01-15)

> **Ziel:** Systematische Umsetzung aller WinUI 3 Best Practices mit Fokus auf Responsive Layouts (VisualStateManager)
> **Status:** AKTIV - Step 1-2 abgeschlossen, **Step 3.1 FERTIG**, Step 3.2 nÃ¤chste
> **PrioritÃ¤t:** Stufe 1 (nach Security-Cleanup, vor ReSharper 0-Warnings)

### Hintergrund: Warum VisualStateManager?

WinUI 3 Apps mÃ¼ssen **responsive** sein - nicht hart-kodierte Layouts fÃ¼r feste FenstergrÃ¶ÃŸen. **VisualStateManager (VSM)** mit **AdaptiveTrigger** ist die Microsoft Best Practice fÃ¼r:

- âœ… Automatische Umschaltung zwischen Layouts basierend auf Fensterbreite
- âœ… Tablet/Touch-UnterstÃ¼tzung (Portrait â†” Landscape)
- âœ… Professionelle Smooth Transitions (keine jarring Layout-Shifts)
- âœ… Kein Code-Behind erforderlich (deklarativ, wartbar)
- âœ… Future-proof fÃ¼r beliebig kleine/groÃŸe Fenster

**MOBAflow Breakpoints definiert:**
- **Compact:** 0-640px (Mobile/kleine Fenster)
- **Medium:** 641-1199px (Tablet/Tablet Landscape)
- **Wide:** 1200px+ (Desktop/groÃŸer Monitor)

**Siehe auch:** Umfassende Dokumentation in `.github/instructions/winui.instructions.md` (neue Sektion "Responsive Layout with VisualStateManager")

### Step 1: VSM-Dokumentation (âœ… FERTIG - 2026-01-15)

**Umgesetzt:**
- âœ… Erweiterte `winui.instructions.md` mit umfassender VSM-ErklÃ¤rung (Conceptual Guide + Code Examples)
- âœ… MOBAflow-spezifische Breakpoints dokumentiert
- âœ… Komplettes TrainControlPage-Beispiel mit 3 States (Wide/Medium/Compact)
- âœ… HÃ¤ufige VSM-Patterns (Hide/Show, Column Width, Stacking)
- âœ… Window-Resize Testing Guide
- âœ… Architecture Decision Log (warum VSM, nicht Custom Controls)

**Ergebnis:** Entwickler verstehen jetzt VSM-Konzept vollstÃ¤ndig und kÃ¶nnen es sofort anwenden.

### Step 2: XAML-Audit aller Haupt-Pages (âœ… FERTIG - 2026-01-15)

**Audit-Ergebnisse:**

| Page | Layout | Status | Breakpoints | PrioritÃ¤t |
|------|--------|--------|------------|-----------|
| **TrainControlPage.xaml** | Grid (3 Spalten, hart-kodiert) | âœ… **VSM IMPLEMENTIERT (2026-01-17)** | Wide: 3 Spalten \| Medium: 2 Spalten \| Compact: Stack | ðŸ”´ âœ… FERTIG |
| **TrackPlanEditorPage.xaml** | Grid (3 Spalten: Toolbox \| Canvas \| Palette) | â³ **NÃ„CHSTE** | Wide: 3 Spalten \| Medium: Canvas Full + Toolbox unten \| Compact: Toolbox Modal | ðŸ”´ HOCH |
| **SignalBoxPage.cs** | Programmatisch (Code-Behind XAML) | âš ï¸ Braucht XAML + VSM | Wide: Grid \| Medium: Compact | ðŸŸ  MITTEL |
| **MainWindow.xaml** | NavigationView (Shell) | â³ Noch zu prÃ¼fen | Wide: Rail sichtbar \| Compact: Hamburger | ðŸŸ  MITTEL |
| **WorkflowsPage.xaml** | ListBox + Editor | â³ Noch zu prÃ¼fen | Wide: Split \| Compact: Modal | ðŸŸ  MITTEL |
| **MonitorPage.xaml** | Horizontal Logs | âœ… Wahrscheinlich OK | - | ðŸŸ¢ NIEDRIG |

**Erkenntnisse:**
- âŒ ~~Keine Page hat aktuell VSM implementiert~~ â†’ TrainControlPage âœ… VSM implementiert
- âœ… TrainControlPage als Vorbild-Implementierung
- âœ… Gute Grundstruktur (Grid-basiert, proper spacing, CardBackground, Fluent Design)
- âš ï¸ SignalBoxPage ist vollstÃ¤ndig Code-Behind generiert (sollte zu XAML migriert werden fÃ¼r Wartbarkeit)

### Step 3: VSM-Implementierung in Haupt-Pages

#### Step 3.1: TrainControlPage.xaml (âœ… FERTIG - 2026-01-17)

**Implementiert:**
- âœ… VSM mit Wide/Medium/Compact States
- âœ… Breakpoints: Wide (1200px+) | Medium (641-1199px) | Compact (0-640px)
- âœ… Wide: [Settings (260px) | Tachometer (*) | Functions (180px)]
- âœ… Medium: [Settings (250px) | Tachometer (*)] - Functions verborgen
- âœ… Compact: Single column, alle Panels gestackt
- âœ… All 21 function buttons (F0-F20) working with Command binding
- âœ… BacklightConverter for button colors
- âœ… Tested with resize from 1920px â†’ 1200px â†’ 640px â†’ 320px
- âœ… Build erfolgreich

**Testing Status:**
- âœ… UI Buttons responsive und klickbar (auch ohne Z21 connection zum Testen)
- âœ… Function button colors zeigen sich korrekt (Background binding)
- âœ… CanExecuteLocoCommand temporarily disabled (`=> true`) fÃ¼r Testing
- âœ… TODO: SpÃ¤ter wieder `_z21.IsConnected` check aktivieren

#### Step 3.2: TrackPlanEditorPage.xaml (ðŸ”´ **AKTUELLE AUFGABE**)

**Aufgabe:** 3-Spalten Layout (Toolbox | Canvas | Properties) â†’ VSM
- Breakpoints:
  - **Wide:** [Toolbox (180px) | Canvas (*) | Properties (240px)]
  - **Medium:** [Canvas full-width] mit Properties darunter oder als Flyout
  - **Compact:** Canvas full-screen, Toolbox/Properties als Modal/Flyout
- Tests: Touch-Simulation, Rotation (Landscape â†” Portrait)
- GeschÃ¤tzter Aufwand: 1-2 Stunden
- Nutzen: Track Planning auf Tablet, bessere Touchscreen-UnterstÃ¼tzung

#### Step 3.3: SignalBoxPage (MITTLERE PRIORITÃ„T)

**Aufgabe:** Von Code-Behind-XAML-Generierung zu echtem XAML + VSM migrieren
- Warum: Wartbarkeit, Performance, Designability, VSM-Integration
- Breakpoints:
  - **Wide:** Signal-Grid + Console Log side-by-side
  - **Compact:** Signal-Grid full-width, Console unten
- Tests: Toolbox Visibility Toggle, Grid Resize
- GeschÃ¤tzter Aufwand: 2-3 Stunden (grÃ¶ÃŸerer Refactoring, aber notwendig)
- Nutzen: Bessere Wartbarkeit, XAML Designer support, Theme consistency

#### Step 3.4: MainWindow.xaml (MITTLERE PRIORITÃ„T)

**Aufgabe:** NavigationView Pane anpassen fÃ¼r Compact Mode
- Breakpoints:
  - **Wide:** Rail sichtbar (links)
  - **Compact:** Hamburger Menu (Pane verborgen, Toggle-Button oben)
- Tests: Window Resize, Fokus auf Accessibility
- GeschÃ¤tzter Aufwand: 1-2 Stunden
- Nutzen: VollstÃ¤ndig responsive App-Shell

#### Step 3.5: WorkflowsPage.xaml (NIEDRIGERE PRIORITÃ„T)

**Aufgabe:** Split-View (ListBox + Editor) â†’ VSM
- Tests: Editor als Modal bei Compact
- GeschÃ¤tzter Aufwand: 1 Stunde

### Step 4-12: Weitere WinUI Best Practices (PENDING)

Nach VSM-Implementierung sollten diese weitere Best Practices umgesetzt werden:

| Step | Aufgabe | Aufwand | Notes |
|------|---------|--------|-------|
| 4 | Refactor Navigation Pattern nach Shell-Standard | 2-3h | INavigationService, IPageFactory bereits vorhanden |
| 5 | UI Thread Dispatching Audit (Z21, Journey, TrainControl Events) | 2-3h | Code-Review fÃ¼r Backgroundâ†’UI Updates |
| 6 | Fluent Design System konsistent | 3-4h | Theme Tokens, Akzentfarben, Transitions |
| 7 | DI-Registration Ã¼berprÃ¼fen (App.xaml.cs) | 1-2h | Service Lifetimes (Singleton vs Transient) |
| 8 | ItemsControl Pattern dokumentieren | 1h | Wann ListView, wann ItemsControl, Virtualization |
| 9 | File I/O Pattern Ã¼berprÃ¼fen | 1h | FilePicker mit Window Handle, Async/Await |
| 10 | Keyboard Shortcuts konsistent | 2h | Ctrl+S, Ctrl+O, F5, Escape Ã¼berprÃ¼fen |
| 11 | Window Management Audit | 1h | Sizing, Centering, Startup State |
| 12 | Finale winui.instructions.md Erweiterung | 1h | Architecture Decision Log, Checklisten |

---

### âœ… NÃ¤chste Aktion: Step 3.2 TrackPlanEditorPage.xaml starten

**Reihenfolge fÃ¼r Implementation:**
1. ~~TrainControlPage.xaml~~ âœ… (Kritisch, gutes Lern-Beispiel) - **FERTIG 2026-01-17**
2. **TrackPlanEditorPage.xaml** (Kritisch fÃ¼r Touch-Szenarien) - **NÃ„CHSTE**
3. SignalBoxPage (GrÃ¶ÃŸeres Refactoring, aber notwendig)
4. MainWindow.xaml (Komplettiert Shell)
5. WorkflowsPage.xaml + MonitorPage.xaml (Optional Refinement)

**GeschÃ¤tzte Gesamtzeit fÃ¼r verbleibende:** ~4-6 Stunden fÃ¼r kritische 2 Pages + Shell

---
