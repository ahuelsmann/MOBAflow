
## ðŸŽ¯ Selection Management Best Practices (Dec 2025)

### **Pattern: Direct Assignment in OnChanged**

**Principle:** Set `CurrentSelectedObject` directly in `OnChanged` handlers instead of using computed properties with priority hierarchies.

#### **âœ… CORRECT: Direct Assignment**

```csharp
// MainWindowViewModel.cs
[ObservableProperty]
private object? currentSelectedObject;

[ObservableProperty]
private JourneyViewModel? selectedJourney;

// MainWindowViewModel.Selection.cs
partial void OnSelectedJourneyChanged(JourneyViewModel? value)
{
    if (value != null)
    {
        CurrentSelectedObject = value;  // âœ… Direct & Explicit!
        CurrentSelectedEntityType = MobaType.Journey;
    }
}

[RelayCommand]
private void SelectJourney(JourneyViewModel? journey)
{
    SelectedJourney = journey;  // âœ… That's it! One line!
}
```

**Why this works:**
1. âœ… **Explicit:** Clear where `CurrentSelectedObject` is set
2. âœ… **Simple:** No hidden logic, no manual clearing needed
3. âœ… **Predictable:** User clicks Journey â†’ Shows Journey (not blocked by children)
4. âœ… **Debuggable:** Breakpoint in `OnChanged` shows flow

---

#### **âŒ WRONG: Computed Property with Priority Hierarchy**

```csharp
// âŒ Anti-Pattern: Complex Getter
public object? CurrentSelectedObject
{
    get
    {
        // Priority hell! Station blocks Journey!
        if (SelectedAction != null) return SelectedAction;
        if (SelectedStation != null) return SelectedStation;  // âŒ Blocks parent!
        if (SelectedJourney != null) return SelectedJourney;  // Never reached!
        if (SelectedWorkflow != null) return SelectedWorkflow;
        // ...
        return null;
    }
}

// âŒ Anti-Pattern: Manual Clearing
[RelayCommand]
private void SelectJourney(JourneyViewModel? journey)
{
    // âŒ Manual state management everywhere!
    SelectedStation = null;
    SelectedAction = null;
    
    SelectedJourney = journey;
    OnPropertyChanged(nameof(CurrentSelectedObject));
}
```

**Why this is wrong:**
1. âŒ **Hidden Logic:** Priority hierarchy not obvious
2. âŒ **Complex:** Manual clearing in every command
3. âŒ **Unpredictable:** Clicking Journey might still show Station
4. âŒ **Hard to Debug:** Where does `CurrentSelectedObject` get set?

---

### **Pattern Comparison**

| Aspect | Computed Property âŒ | Direct Assignment âœ… |
|--------|---------------------|---------------------|
| **LOC per Command** | 5-10 lines | 1 line |
| **Manual Clearing** | Yes, everywhere | No, automatic |
| **Hidden Logic** | Yes (priority) | No, explicit |
| **Debuggability** | Hard | Easy |
| **Maintainability** | Low | High |
| **User Expectation** | Violated | Met |

---

### **Why We Learned This (Dec 2025)**

**Problem:** Journey â†’ Station â†’ Journey nochmal â†’ Properties zeigt **Station** (not Journey!)

**Root Cause:** Priority Hierarchy in computed property blocked parent selection:
```csharp
if (SelectedStation != null) return SelectedStation;  // âŒ Always returns Station!
if (SelectedJourney != null) return SelectedJourney;  // Never reached!
```

**Solution Evolution:**
1. âŒ **Attempt 1:** RefreshCurrentSelection Command â†’ Didn't clear children
2. âŒ **Attempt 2:** EntitySelectionManager Callbacks â†’ Too complex
3. âŒ **Attempt 3:** Manual Child Clearing â†’ Boilerplate everywhere
4. âœ… **Final Solution:** Direct Assignment in OnChanged â†’ Simple & Works!

---

### **KISS Principle for MVVM Properties**

**Rule:** Observable properties should be simple and setable. Complex logic belongs in `OnChanged` handlers.

#### **âœ… DO:**
```csharp
[ObservableProperty]
private ItemViewModel? selectedItem;

partial void OnSelectedItemChanged(ItemViewModel? value)
{
    CurrentView = value;           // Explicit
    UpdateRelatedState(value);     // Clear intent
}
```

#### **âŒ DON'T:**
```csharp
public object? CurrentView => A ?? B ?? C ?? D;  // Complex getter
public object? CurrentView
{
    get
    {
        if (complex_condition) return ComputeComplex();
        return Default;
    }
}
```

---

### **Lesson Learned: Question Complexity**

**If a solution requires:**
- Manual state clearing in every command
- Callbacks/Helpers for simple operations
- Priority hierarchies

â†’ **The design is probably wrong!** Ask: _"Can I simplify this?"_

**Simple is not simplistic. Simple is elegant.** ðŸŽ¯

---

**Date:** 2025-12-09  
**Related Files:** `MainWindowViewModel.Selection.cs`, `MainWindowViewModel.cs`  
**Pattern:** Direct Assignment Pattern (MVVM Best Practice)
